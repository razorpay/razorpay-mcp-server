
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>razorpay-mcp-server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/razorpay/razorpay-mcp-server/cmd/razorpay-mcp-server/main.go (83.3%)</option>
				
				<option value="file1">github.com/razorpay/razorpay-mcp-server/cmd/razorpay-mcp-server/stdio.go (51.4%)</option>
				
				<option value="file2">github.com/razorpay/razorpay-mcp-server/pkg/contextkey/context_key.go (100.0%)</option>
				
				<option value="file3">github.com/razorpay/razorpay-mcp-server/pkg/log/config.go (100.0%)</option>
				
				<option value="file4">github.com/razorpay/razorpay-mcp-server/pkg/log/log.go (55.6%)</option>
				
				<option value="file5">github.com/razorpay/razorpay-mcp-server/pkg/log/slog.go (91.1%)</option>
				
				<option value="file6">github.com/razorpay/razorpay-mcp-server/pkg/mcpgo/server.go (69.2%)</option>
				
				<option value="file7">github.com/razorpay/razorpay-mcp-server/pkg/mcpgo/stdio.go (100.0%)</option>
				
				<option value="file8">github.com/razorpay/razorpay-mcp-server/pkg/mcpgo/tool.go (99.3%)</option>
				
				<option value="file9">github.com/razorpay/razorpay-mcp-server/pkg/observability/observability.go (100.0%)</option>
				
				<option value="file10">github.com/razorpay/razorpay-mcp-server/pkg/razorpay/mock/server.go (90.0%)</option>
				
				<option value="file11">github.com/razorpay/razorpay-mcp-server/pkg/razorpay/orders.go (93.4%)</option>
				
				<option value="file12">github.com/razorpay/razorpay-mcp-server/pkg/razorpay/payment_links.go (90.4%)</option>
				
				<option value="file13">github.com/razorpay/razorpay-mcp-server/pkg/razorpay/payments.go (97.7%)</option>
				
				<option value="file14">github.com/razorpay/razorpay-mcp-server/pkg/razorpay/payouts.go (92.9%)</option>
				
				<option value="file15">github.com/razorpay/razorpay-mcp-server/pkg/razorpay/qr_codes.go (92.4%)</option>
				
				<option value="file16">github.com/razorpay/razorpay-mcp-server/pkg/razorpay/refunds.go (93.1%)</option>
				
				<option value="file17">github.com/razorpay/razorpay-mcp-server/pkg/razorpay/server.go (95.2%)</option>
				
				<option value="file18">github.com/razorpay/razorpay-mcp-server/pkg/razorpay/settlements.go (89.5%)</option>
				
				<option value="file19">github.com/razorpay/razorpay-mcp-server/pkg/razorpay/test_helpers.go (96.7%)</option>
				
				<option value="file20">github.com/razorpay/razorpay-mcp-server/pkg/razorpay/tokens.go (100.0%)</option>
				
				<option value="file21">github.com/razorpay/razorpay-mcp-server/pkg/razorpay/tools.go (94.7%)</option>
				
				<option value="file22">github.com/razorpay/razorpay-mcp-server/pkg/razorpay/tools_params.go (99.3%)</option>
				
				<option value="file23">github.com/razorpay/razorpay-mcp-server/pkg/toolsets/toolsets.go (97.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">//nolint:lll
package main

import (
        "fmt"
        "os"

        "github.com/spf13/cobra"
        "github.com/spf13/viper"
)

var (
        version = "version"
        commit  = "commit"
        date    = "date"
)

var cfgFile string

var rootCmd = &amp;cobra.Command{
        Use:     "server",
        Short:   "Razorpay MCP Server",
        Version: fmt.Sprintf("%s\ncommit %s\ndate %s", version, commit, date),
}

// Execute runs the root command and handles any errors
func Execute() <span class="cov0" title="0">{
        err := rootCmd.Execute()
        if err != nil </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
}

func init() <span class="cov8" title="1">{
        cobra.OnInitialize(initConfig)

        // flags will be available for all subcommands
        rootCmd.PersistentFlags().StringP("key", "k", "", "your razorpay api key")
        rootCmd.PersistentFlags().StringP("secret", "s", "", "your razorpay api secret")
        rootCmd.PersistentFlags().StringP("log-file", "l", "", "path to the log file")
        rootCmd.PersistentFlags().StringSliceP("toolsets", "t", []string{}, "comma-separated list of toolsets to enable")
        rootCmd.PersistentFlags().Bool("read-only", false, "run server in read-only mode")

        // bind flags to viper
        _ = viper.BindPFlag("key", rootCmd.PersistentFlags().Lookup("key"))
        _ = viper.BindPFlag("secret", rootCmd.PersistentFlags().Lookup("secret"))
        _ = viper.BindPFlag("log_file", rootCmd.PersistentFlags().Lookup("log-file"))
        _ = viper.BindPFlag("toolsets", rootCmd.PersistentFlags().Lookup("toolsets"))
        _ = viper.BindPFlag("read_only", rootCmd.PersistentFlags().Lookup("read-only"))

        // Set environment variable mappings
        _ = viper.BindEnv("key", "RAZORPAY_KEY_ID")        // Maps RAZORPAY_KEY_ID to key
        _ = viper.BindEnv("secret", "RAZORPAY_KEY_SECRET") // Maps RAZORPAY_KEY_SECRET to secret

        // Enable environment variable reading
        viper.AutomaticEnv()

        // subcommands
        rootCmd.AddCommand(stdioCmd)
}</span>

// initConfig reads in config file and ENV variables if set.
func initConfig() <span class="cov8" title="1">{
        if cfgFile != "" </span><span class="cov8" title="1">{
                viper.SetConfigFile(cfgFile)
        }</span> else<span class="cov8" title="1"> {
                home, err := os.UserHomeDir()
                cobra.CheckErr(err)

                viper.AddConfigPath(home)
                viper.SetConfigType("yaml")
                viper.SetConfigName(".razorpay-mcp-server")
        }</span>

        <span class="cov8" title="1">viper.AutomaticEnv()

        if err := viper.ReadInConfig(); err == nil </span><span class="cov8" title="1">{
                fmt.Fprintln(os.Stderr, "Using config file:", viper.ConfigFileUsed())
        }</span>
}

func main() <span class="cov0" title="0">{
        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "context"
        "fmt"
        "io"
        stdlog "log"
        "log/slog"
        "os"
        "os/signal"
        "syscall"

        "github.com/spf13/cobra"
        "github.com/spf13/viper"

        rzpsdk "github.com/razorpay/razorpay-go"

        "github.com/razorpay/razorpay-mcp-server/pkg/log"
        "github.com/razorpay/razorpay-mcp-server/pkg/mcpgo"
        "github.com/razorpay/razorpay-mcp-server/pkg/observability"
        "github.com/razorpay/razorpay-mcp-server/pkg/razorpay"
)

// stdioCmd starts the mcp server in stdio transport mode
var stdioCmd = &amp;cobra.Command{
        Use:   "stdio",
        Short: "start the stdio server",
        Run: func(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
                logPath := viper.GetString("log_file")

                config := log.NewConfig(
                        log.WithMode(log.ModeStdio),
                        log.WithLogLevel(slog.LevelInfo),
                        log.WithLogPath(logPath),
                )

                ctx, logger := log.New(context.Background(), config)

                // Create observability with SSE mode
                obs := observability.New(
                        observability.WithLoggingService(logger),
                )

                key := viper.GetString("key")
                secret := viper.GetString("secret")
                client := rzpsdk.NewClient(key, secret)

                client.SetUserAgent("razorpay-mcp" + version + "/stdio")

                // Get toolsets to enable from config
                enabledToolsets := viper.GetStringSlice("toolsets")

                // Get read-only mode from config
                readOnly := viper.GetBool("read_only")

                err := runStdioServer(ctx, obs, client, enabledToolsets, readOnly)
                if err != nil </span><span class="cov0" title="0">{
                        obs.Logger.Errorf(ctx,
                                "error running stdio server", "error", err)
                        stdlog.Fatalf("failed to run stdio server: %v", err)
                }</span>
        },
}

func runStdioServer(
        ctx context.Context,
        obs *observability.Observability,
        client *rzpsdk.Client,
        enabledToolsets []string,
        readOnly bool,
) error <span class="cov8" title="1">{
        ctx, stop := signal.NotifyContext(
                ctx,
                os.Interrupt,
                syscall.SIGTERM,
        )
        defer stop()

        srv, err := razorpay.NewRzpMcpServer(obs, client, enabledToolsets, readOnly)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to create server: %w", err)
        }</span>

        <span class="cov8" title="1">stdioSrv, err := mcpgo.NewStdioServer(srv)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create stdio server: %w", err)
        }</span>

        <span class="cov8" title="1">in, out := io.Reader(os.Stdin), io.Writer(os.Stdout)
        errC := make(chan error, 1)
        go func() </span><span class="cov8" title="1">{
                obs.Logger.Infof(ctx, "starting server")
                errC &lt;- stdioSrv.Listen(ctx, in, out)
        }</span>()

        <span class="cov8" title="1">_, _ = fmt.Fprintf(
                os.Stderr,
                "Razorpay MCP Server running on stdio\n",
        )

        // Wait for shutdown signal
        select </span>{
        case &lt;-ctx.Done():<span class="cov8" title="1">
                obs.Logger.Infof(ctx, "shutting down server...")
                return nil</span>
        case err := &lt;-errC:<span class="cov8" title="1">
                if err != nil </span><span class="cov0" title="0">{
                        obs.Logger.Errorf(ctx, "server error", "error", err)
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package contextkey

import (
        "context"
)

// contextKey is a type used for context value keys to avoid key collisions.
type contextKey string

// Context keys for storing various values.
const (
        clientKey contextKey = "client"
)

// WithClient returns a new context with the client instance attached.
func WithClient(ctx context.Context, client interface{}) context.Context <span class="cov8" title="1">{
        return context.WithValue(ctx, clientKey, client)
}</span>

// ClientFromContext extracts the client instance from the context.
// Returns nil if no client is found.
func ClientFromContext(ctx context.Context) interface{} <span class="cov8" title="1">{
        return ctx.Value(clientKey)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package log

import (
        "log/slog"
)

// Logger modes
const (
        ModeStdio = "stdio"
)

// Config holds logger configuration with options pattern.
// Use NewConfig to create a new configuration with default values,
// then customize it using the With* option functions.
type Config struct {
        // mode determines the logger type (stdio or sse)
        mode string
        // Embedded configs for different logger types
        slog slogConfig
}

// slogConfig holds slog-specific configuration for stdio mode
type slogConfig struct {
        // path is the file path where logs will be written
        path string
        // logLevel sets the minimum log level to output
        logLevel slog.Leveler
}

// GetMode returns the logger mode (stdio or sse)
func (c Config) GetMode() string <span class="cov8" title="1">{
        return c.mode
}</span>

// GetSlogConfig returns the slog logger configuration
func (c Config) GetSlogConfig() slogConfig <span class="cov8" title="1">{
        return c.slog
}</span>

// GetLogLevel returns the log level
func (z Config) GetLogLevel() slog.Leveler <span class="cov8" title="1">{
        return z.slog.logLevel
}</span>

// GetPath returns the log file path
func (s slogConfig) GetPath() string <span class="cov8" title="1">{
        return s.path
}</span>

// ConfigOption represents a configuration option function
type ConfigOption func(*Config)

// WithMode sets the logger mode (stdio or sse)
func WithMode(mode string) ConfigOption <span class="cov8" title="1">{
        return func(c *Config) </span><span class="cov8" title="1">{
                c.mode = mode
        }</span>
}

// WithLogPath sets the log file path
func WithLogPath(path string) ConfigOption <span class="cov8" title="1">{
        return func(c *Config) </span><span class="cov8" title="1">{
                c.slog.path = path
        }</span>
}

// WithLogLevel sets the log level for the mode
func WithLogLevel(level slog.Level) ConfigOption <span class="cov8" title="1">{
        return func(c *Config) </span><span class="cov8" title="1">{
                c.slog.logLevel = level
        }</span>
}

// NewConfig creates a new config with default values.
// By default, it uses stdio mode with info log level.
// Use With* options to customize the configuration.
func NewConfig(opts ...ConfigOption) *Config <span class="cov8" title="1">{
        config := &amp;Config{
                mode: ModeStdio,
                slog: slogConfig{
                        logLevel: slog.LevelInfo,
                },
        }

        for _, opt := range opts </span><span class="cov8" title="1">{
                opt(config)
        }</span>

        <span class="cov8" title="1">return config</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package log

import (
        "context"
        "fmt"
        "os"
)

// Logger is an interface for logging, it is used internally
// at present but has scope for external implementations
//
//nolint:interfacebloat
type Logger interface {
        Infof(ctx context.Context, format string, args ...interface{})
        Errorf(ctx context.Context, format string, args ...interface{})
        Fatalf(ctx context.Context, format string, args ...interface{})
        Debugf(ctx context.Context, format string, args ...interface{})
        Warningf(ctx context.Context, format string, args ...interface{})
        Close() error
}

// New creates a new logger based on the provided configuration.
// It returns an enhanced context and a logger implementation.
// For stdio mode, it creates a file-based slog logger.
// For sse mode, it creates a stdout-based slog logger.
func New(ctx context.Context, config *Config) (context.Context, Logger) <span class="cov8" title="1">{
        var (
                logger Logger
                err    error
        )

        switch config.GetMode() </span>{
        case ModeStdio:<span class="cov8" title="1">
                // For stdio mode, use slog logger that writes to file
                logger, err = NewSloggerWithFile(config.GetSlogConfig().GetPath())
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("failed to initialize logger\n")
                        os.Exit(1)
                }</span>
        default:<span class="cov0" title="0">
                fmt.Printf("failed to initialize logger\n")
                os.Exit(1)</span>
        }

        <span class="cov8" title="1">return ctx, logger</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package log

import (
        "context"
        "fmt"
        "log"
        "log/slog"
        "os"
        "path/filepath"
)

// slogLogger implements Logger interface using slog
type slogLogger struct {
        logger *slog.Logger
        closer func() error
}

// logWithLevel is a helper function that handles common logging functionality
func (s *slogLogger) logWithLevel(
        ctx context.Context,
        level slog.Level,
        format string,
        args ...interface{},
) <span class="cov8" title="1">{
        // Extract context fields and add them as slog attributes
        attrs := s.extractContextAttrs(ctx)

        // Convert args to slog attributes
        attrs = append(attrs, s.convertArgsToAttrs(args...)...)

        s.logger.LogAttrs(ctx, level, format, attrs...)
}</span>

// Infof logs an info message with context fields
func (s *slogLogger) Infof(
        ctx context.Context, format string, args ...interface{}) <span class="cov8" title="1">{
        s.logWithLevel(ctx, slog.LevelInfo, format, args...)
}</span>

// Errorf logs an error message with context fields
func (s *slogLogger) Errorf(
        ctx context.Context, format string, args ...interface{}) <span class="cov8" title="1">{
        s.logWithLevel(ctx, slog.LevelError, format, args...)
}</span>

// Fatalf logs a fatal message with context fields and exits
func (s *slogLogger) Fatalf(
        ctx context.Context, format string, args ...interface{}) <span class="cov0" title="0">{
        s.logWithLevel(ctx, slog.LevelError, format, args...)
        os.Exit(1)
}</span>

// Debugf logs a debug message with context fields
func (s *slogLogger) Debugf(
        ctx context.Context, format string, args ...interface{}) <span class="cov8" title="1">{
        s.logWithLevel(ctx, slog.LevelDebug, format, args...)
}</span>

// Warningf logs a warning message with context fields
func (s *slogLogger) Warningf(
        ctx context.Context, format string, args ...interface{}) <span class="cov8" title="1">{
        s.logWithLevel(ctx, slog.LevelWarn, format, args...)
}</span>

// extractContextAttrs extracts fields from context and converts to slog.Attr
func (s *slogLogger) extractContextAttrs(_ context.Context) []slog.Attr <span class="cov8" title="1">{
        // Always include all fields as attributes
        return []slog.Attr{}
}</span>

// convertArgsToAttrs converts key-value pairs to slog.Attr
func (s *slogLogger) convertArgsToAttrs(args ...interface{}) []slog.Attr <span class="cov8" title="1">{
        if len(args) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">var attrs []slog.Attr
        for i := 0; i &lt; len(args)-1; i += 2 </span><span class="cov8" title="1">{
                if i+1 &lt; len(args) </span><span class="cov8" title="1">{
                        key, ok := args[i].(string)
                        if !ok </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">value := args[i+1]
                        attrs = append(attrs, slog.Any(key, value))</span>
                }
        }
        <span class="cov8" title="1">return attrs</span>
}

// Close implements the Logger interface Close method
func (s *slogLogger) Close() error <span class="cov8" title="1">{
        if s.closer != nil </span><span class="cov8" title="1">{
                return s.closer()
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// NewSlogger returns a new slog.Logger implementation of Logger interface.
// If path to log file is not provided then logger uses stderr for stdio mode
// If the log file cannot be opened, falls back to stderr
func NewSlogger() (*slogLogger, error) <span class="cov8" title="1">{
        // For stdio mode, always use stderr regardless of path
        // This ensures logs don't interfere with MCP protocol on stdout
        return &amp;slogLogger{
                logger: slog.New(slog.NewTextHandler(os.Stderr, &amp;slog.HandlerOptions{
                        Level: slog.LevelInfo,
                })),
        }, nil
}</span>

func NewSloggerWithStdout(config *Config) (*slogLogger, error) <span class="cov8" title="1">{
        // For stdio mode, always use Stdout regardless of path
        // This ensures logs don't interfere with MCP protocol on stdout
        return &amp;slogLogger{
                logger: slog.New(slog.NewJSONHandler(os.Stdout, &amp;slog.HandlerOptions{
                        Level: config.slog.logLevel,
                })),
        }, nil
}</span>

// getDefaultLogPath returns an absolute path for the logs directory
func getDefaultLogPath() string <span class="cov8" title="1">{
        execPath, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                // Fallback to temp directory if we can't determine executable path
                return filepath.Join(os.TempDir(), "razorpay-mcp-server-logs")
        }</span>

        <span class="cov8" title="1">execDir := filepath.Dir(execPath)

        return filepath.Join(execDir, "logs")</span>
}

// NewSloggerWithFile returns a new slog.Logger.
// If path to log file is not provided then
// logger uses a default path next to the executable
// If the log file cannot be opened, falls back to stderr
//
// TODO: add redaction of sensitive data
func NewSloggerWithFile(path string) (*slogLogger, error) <span class="cov8" title="1">{
        if path == "" </span><span class="cov8" title="1">{
                path = getDefaultLogPath()
        }</span>

        <span class="cov8" title="1">file, err := os.OpenFile(path, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
        if err != nil </span><span class="cov8" title="1">{
                // Fall back to stderr if we can't open the log file
                fmt.Fprintf(
                        os.Stderr,
                        "Warning: Failed to open log file: %v\nFalling back to stderr\n",
                        err,
                )
                logger := slog.New(slog.NewTextHandler(os.Stderr, nil))
                noop := func() error </span><span class="cov8" title="1">{ return nil }</span>
                <span class="cov8" title="1">return &amp;slogLogger{
                        logger: logger,
                        closer: noop,
                }, nil</span>
        }

        <span class="cov8" title="1">fmt.Fprintf(os.Stderr, "logs are stored in: %v\n", path)
        return &amp;slogLogger{
                logger: slog.New(slog.NewTextHandler(file, nil)),
                closer: func() error </span><span class="cov8" title="1">{
                        if err := file.Close(); err != nil </span><span class="cov0" title="0">{
                                log.Printf("close log file: %v", err)
                        }</span>

                        <span class="cov8" title="1">return nil</span>
                },
        }, nil
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package mcpgo

import (
        "context"

        "github.com/mark3labs/mcp-go/mcp"
        "github.com/mark3labs/mcp-go/server"

        "github.com/razorpay/razorpay-mcp-server/pkg/observability"
)

// Server defines the minimal MCP server interface needed by the application
type Server interface {
        // AddTools adds tools to the server
        AddTools(tools ...Tool)
}

// NewMcpServer creates a new MCP server
func NewMcpServer(name, version string, opts ...ServerOption) *Mark3labsImpl <span class="cov8" title="1">{
        // Create option setter to collect mcp options
        optSetter := &amp;mark3labsOptionSetter{
                mcpOptions: []server.ServerOption{},
        }

        // Apply our options, which will populate the mcp options
        for _, opt := range opts </span><span class="cov8" title="1">{
                _ = opt(optSetter)
        }</span>

        // Create the underlying mcp server
        <span class="cov8" title="1">mcpServer := server.NewMCPServer(
                name,
                version,
                optSetter.mcpOptions...,
        )

        return &amp;Mark3labsImpl{
                McpServer: mcpServer,
                Name:      name,
                Version:   version,
        }</span>
}

// Mark3labsImpl implements the Server interface using mark3labs/mcp-go
type Mark3labsImpl struct {
        McpServer *server.MCPServer
        Name      string
        Version   string
}

// mark3labsOptionSetter is used to apply options to the server
type mark3labsOptionSetter struct {
        mcpOptions []server.ServerOption
}

func (s *mark3labsOptionSetter) SetOption(option interface{}) error <span class="cov8" title="1">{
        if opt, ok := option.(server.ServerOption); ok </span><span class="cov8" title="1">{
                s.mcpOptions = append(s.mcpOptions, opt)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// AddTools adds tools to the server
func (s *Mark3labsImpl) AddTools(tools ...Tool) <span class="cov8" title="1">{
        // Convert our Tool to mcp's ServerTool
        var mcpTools []server.ServerTool
        for _, tool := range tools </span><span class="cov8" title="1">{
                mcpTools = append(mcpTools, tool.toMCPServerTool())
        }</span>
        <span class="cov8" title="1">s.McpServer.AddTools(mcpTools...)</span>
}

// OptionSetter is an interface for setting options on a configurable object
type OptionSetter interface {
        SetOption(option interface{}) error
}

// ServerOption is a function that configures a Server
type ServerOption func(OptionSetter) error

// WithLogging returns a server option that enables logging
func WithLogging() ServerOption <span class="cov8" title="1">{
        return func(s OptionSetter) error </span><span class="cov8" title="1">{
                return s.SetOption(server.WithLogging())
        }</span>
}

func WithHooks(hooks *server.Hooks) ServerOption <span class="cov8" title="1">{
        return func(s OptionSetter) error </span><span class="cov8" title="1">{
                return s.SetOption(server.WithHooks(hooks))
        }</span>
}

// WithResourceCapabilities returns a server option
// that enables resource capabilities
func WithResourceCapabilities(read, list bool) ServerOption <span class="cov8" title="1">{
        return func(s OptionSetter) error </span><span class="cov8" title="1">{
                return s.SetOption(server.WithResourceCapabilities(read, list))
        }</span>
}

// WithToolCapabilities returns a server option that enables tool capabilities
func WithToolCapabilities(enabled bool) ServerOption <span class="cov8" title="1">{
        return func(s OptionSetter) error </span><span class="cov8" title="1">{
                return s.SetOption(server.WithToolCapabilities(enabled))
        }</span>
}

// SetupHooks creates and configures the server hooks with logging
func SetupHooks(obs *observability.Observability) *server.Hooks <span class="cov8" title="1">{
        hooks := &amp;server.Hooks{}
        hooks.AddBeforeAny(func(ctx context.Context, id any, method mcp.MCPMethod,
                message any) </span><span class="cov0" title="0">{
                obs.Logger.Infof(ctx, "MCP_METHOD_CALLED",
                        "method", method,
                        "id", id,
                        "message", message)
        }</span>)

        <span class="cov8" title="1">hooks.AddOnSuccess(func(ctx context.Context, id any, method mcp.MCPMethod,
                message any, result any) </span><span class="cov0" title="0">{
                logResult := result
                if method == mcp.MethodToolsList </span><span class="cov0" title="0">{
                        if r, ok := result.(*mcp.ListToolsResult); ok </span><span class="cov0" title="0">{
                                simplifiedTools := make([]string, 0, len(r.Tools))
                                for _, tool := range r.Tools </span><span class="cov0" title="0">{
                                        simplifiedTools = append(simplifiedTools, tool.Name)
                                }</span>
                                // Create new map for logging with just the tool names
                                <span class="cov0" title="0">logResult = map[string]interface{}{
                                        "tools": simplifiedTools,
                                }</span>
                        }
                }

                <span class="cov0" title="0">obs.Logger.Infof(ctx, "MCP_METHOD_SUCCEEDED",
                        "method", method,
                        "id", id,
                        "result", logResult)</span>
        })

        <span class="cov8" title="1">hooks.AddOnError(func(ctx context.Context, id any, method mcp.MCPMethod,
                message any, err error) </span><span class="cov0" title="0">{
                obs.Logger.Infof(ctx, "MCP_METHOD_FAILED",
                        "method", method,
                        "id", id,
                        "message", message,
                        "error", err)
        }</span>)

        <span class="cov8" title="1">hooks.AddBeforeCallTool(func(ctx context.Context, id any,
                message *mcp.CallToolRequest) </span><span class="cov0" title="0">{
                obs.Logger.Infof(ctx, "TOOL_CALL_STARTED",
                        "id", id,
                        "request", message)
        }</span>)

        <span class="cov8" title="1">hooks.AddAfterCallTool(func(ctx context.Context, id any,
                message *mcp.CallToolRequest, result *mcp.CallToolResult) </span><span class="cov0" title="0">{
                obs.Logger.Infof(ctx, "TOOL_CALL_COMPLETED",
                        "id", id,
                        "request", message,
                        "result", result)
        }</span>)

        <span class="cov8" title="1">return hooks</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package mcpgo

import (
        "context"
        "errors"
        "fmt"
        "io"

        "github.com/mark3labs/mcp-go/server"
)

// ErrInvalidServerImplementation indicates that the server
// implementation is not compatible
var ErrInvalidServerImplementation = errors.New(
        "invalid server implementation",
)

// NewStdioServer creates a new stdio transport server
func NewStdioServer(mcpServer Server) (*mark3labsStdioImpl, error) <span class="cov8" title="1">{
        sImpl, ok := mcpServer.(*Mark3labsImpl)
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%w: expected *Mark3labsImpl, got %T",
                        ErrInvalidServerImplementation, mcpServer)
        }</span>

        <span class="cov8" title="1">return &amp;mark3labsStdioImpl{
                mcpStdioServer: server.NewStdioServer(sImpl.McpServer),
        }, nil</span>
}

// mark3labsStdioImpl implements the TransportServer
// interface for stdio transport
type mark3labsStdioImpl struct {
        mcpStdioServer *server.StdioServer
}

// Listen implements the TransportServer interface
func (s *mark3labsStdioImpl) Listen(
        ctx context.Context, in io.Reader, out io.Writer) error <span class="cov8" title="1">{
        return s.mcpStdioServer.Listen(ctx, in, out)
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package mcpgo

import (
        "context"
        "encoding/json"

        "github.com/mark3labs/mcp-go/mcp"
        "github.com/mark3labs/mcp-go/server"
)

// ToolHandler handles tool calls
type ToolHandler func(
        ctx context.Context,
        request CallToolRequest) (*ToolResult, error)

// CallToolRequest represents a request to call a tool
type CallToolRequest struct {
        Name      string
        Arguments any
}

// ToolResult represents the result of a tool call
type ToolResult struct {
        Text    string
        IsError bool
        Content []interface{}
}

// Tool represents a tool that can be added to the server
type Tool interface {
        // internal method to convert to mcp's ServerTool
        toMCPServerTool() server.ServerTool

        // GetHandler internal method for fetching the underlying handler
        GetHandler() ToolHandler
}

// PropertyOption represents a customization option for
// a parameter's schema
type PropertyOption func(schema map[string]interface{})

// Min sets the minimum value for a number parameter or
// minimum length for a string
func Min(value float64) PropertyOption <span class="cov8" title="1">{
        return func(schema map[string]interface{}) </span><span class="cov8" title="1">{
                propType, ok := schema["type"].(string)
                if !ok </span><span class="cov8" title="1">{
                        return
                }</span>

                <span class="cov8" title="1">switch propType </span>{
                case "number", "integer":<span class="cov8" title="1">
                        schema["minimum"] = value</span>
                case "string":<span class="cov8" title="1">
                        schema["minLength"] = int(value)</span>
                case "array":<span class="cov8" title="1">
                        schema["minItems"] = int(value)</span>
                }
        }
}

// Max sets the maximum value for a number parameter or
// maximum length for a string
func Max(value float64) PropertyOption <span class="cov8" title="1">{
        return func(schema map[string]interface{}) </span><span class="cov8" title="1">{
                propType, ok := schema["type"].(string)
                if !ok </span><span class="cov8" title="1">{
                        return
                }</span>

                <span class="cov8" title="1">switch propType </span>{
                case "number", "integer":<span class="cov8" title="1">
                        schema["maximum"] = value</span>
                case "string":<span class="cov8" title="1">
                        schema["maxLength"] = int(value)</span>
                case "array":<span class="cov8" title="1">
                        schema["maxItems"] = int(value)</span>
                }
        }
}

// Pattern sets a regex pattern for string validation
func Pattern(pattern string) PropertyOption <span class="cov8" title="1">{
        return func(schema map[string]interface{}) </span><span class="cov8" title="1">{
                propType, ok := schema["type"].(string)
                if !ok || propType != "string" </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">schema["pattern"] = pattern</span>
        }
}

// Enum sets allowed values for a parameter
func Enum(values ...interface{}) PropertyOption <span class="cov8" title="1">{
        return func(schema map[string]interface{}) </span><span class="cov8" title="1">{
                schema["enum"] = values
        }</span>
}

// DefaultValue sets a default value for a parameter
func DefaultValue(value interface{}) PropertyOption <span class="cov8" title="1">{
        return func(schema map[string]interface{}) </span><span class="cov8" title="1">{
                schema["default"] = value
        }</span>
}

// MaxProperties sets the maximum number of properties for an object
func MaxProperties(max int) PropertyOption <span class="cov8" title="1">{
        return func(schema map[string]interface{}) </span><span class="cov8" title="1">{
                propType, ok := schema["type"].(string)
                if !ok || propType != "object" </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">schema["maxProperties"] = max</span>
        }
}

// MinProperties sets the minimum number of properties for an object
func MinProperties(min int) PropertyOption <span class="cov8" title="1">{
        return func(schema map[string]interface{}) </span><span class="cov8" title="1">{
                propType, ok := schema["type"].(string)
                if !ok || propType != "object" </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">schema["minProperties"] = min</span>
        }
}

// Required sets the tool parameter as required.
// When a parameter is marked as required, the client must provide a value
// for this parameter or the tool call will fail with an error.
func Required() PropertyOption <span class="cov8" title="1">{
        return func(schema map[string]interface{}) </span><span class="cov8" title="1">{
                schema["required"] = true
        }</span>
}

// Description sets the description for the tool parameter.
// The description should explain the purpose of the parameter, expected format,
// and any relevant constraints.
func Description(desc string) PropertyOption <span class="cov8" title="1">{
        return func(schema map[string]interface{}) </span><span class="cov8" title="1">{
                schema["description"] = desc
        }</span>
}

// ToolParameter represents a parameter for a tool
type ToolParameter struct {
        Name   string
        Schema map[string]interface{}
}

// applyPropertyOptions applies the given property options to
// the parameter schema
func (p *ToolParameter) applyPropertyOptions(opts ...PropertyOption) <span class="cov8" title="1">{
        for _, opt := range opts </span><span class="cov8" title="1">{
                opt(p.Schema)
        }</span>
}

// WithString creates a string parameter with optional property options
func WithString(name string, opts ...PropertyOption) ToolParameter <span class="cov8" title="1">{
        param := ToolParameter{
                Name:   name,
                Schema: map[string]interface{}{"type": "string"},
        }
        param.applyPropertyOptions(opts...)
        return param
}</span>

// WithNumber creates a number parameter with optional property options
func WithNumber(name string, opts ...PropertyOption) ToolParameter <span class="cov8" title="1">{
        param := ToolParameter{
                Name:   name,
                Schema: map[string]interface{}{"type": "number"},
        }
        param.applyPropertyOptions(opts...)
        return param
}</span>

// WithBoolean creates a boolean parameter with optional property options
func WithBoolean(name string, opts ...PropertyOption) ToolParameter <span class="cov8" title="1">{
        param := ToolParameter{
                Name:   name,
                Schema: map[string]interface{}{"type": "boolean"},
        }
        param.applyPropertyOptions(opts...)
        return param
}</span>

// WithObject creates an object parameter with optional property options
func WithObject(name string, opts ...PropertyOption) ToolParameter <span class="cov8" title="1">{
        param := ToolParameter{
                Name:   name,
                Schema: map[string]interface{}{"type": "object"},
        }
        param.applyPropertyOptions(opts...)
        return param
}</span>

// WithArray creates an array parameter with optional property options
func WithArray(name string, opts ...PropertyOption) ToolParameter <span class="cov8" title="1">{
        param := ToolParameter{
                Name:   name,
                Schema: map[string]interface{}{"type": "array"},
        }
        param.applyPropertyOptions(opts...)
        return param
}</span>

// mark3labsToolImpl implements the Tool interface
type mark3labsToolImpl struct {
        name        string
        description string
        handler     ToolHandler
        parameters  []ToolParameter
}

// NewTool creates a new tool with the given
// Name, description, parameters and handler
func NewTool(
        name,
        description string,
        parameters []ToolParameter,
        handler ToolHandler) *mark3labsToolImpl <span class="cov8" title="1">{
        return &amp;mark3labsToolImpl{
                name:        name,
                description: description,
                handler:     handler,
                parameters:  parameters,
        }
}</span>

// addNumberPropertyOptions adds number-specific options to the property options
func addNumberPropertyOptions(
        propOpts []mcp.PropertyOption,
        schema map[string]interface{}) []mcp.PropertyOption <span class="cov8" title="1">{
        // Add minimum if present
        if min, ok := schema["minimum"].(float64); ok </span><span class="cov8" title="1">{
                propOpts = append(propOpts, mcp.Min(min))
        }</span>

        // Add maximum if present
        <span class="cov8" title="1">if max, ok := schema["maximum"].(float64); ok </span><span class="cov8" title="1">{
                propOpts = append(propOpts, mcp.Max(max))
        }</span>

        <span class="cov8" title="1">return propOpts</span>
}

// addStringPropertyOptions adds string-specific options to the property options
func addStringPropertyOptions(
        propOpts []mcp.PropertyOption,
        schema map[string]interface{}) []mcp.PropertyOption <span class="cov8" title="1">{
        // Add minLength if present
        if minLength, ok := schema["minLength"].(int); ok </span><span class="cov8" title="1">{
                propOpts = append(propOpts, mcp.MinLength(minLength))
        }</span>

        // Add maxLength if present
        <span class="cov8" title="1">if maxLength, ok := schema["maxLength"].(int); ok </span><span class="cov8" title="1">{
                propOpts = append(propOpts, mcp.MaxLength(maxLength))
        }</span>

        // Add pattern if present
        <span class="cov8" title="1">if pattern, ok := schema["pattern"].(string); ok </span><span class="cov8" title="1">{
                propOpts = append(propOpts, mcp.Pattern(pattern))
        }</span>

        <span class="cov8" title="1">return propOpts</span>
}

// addDefaultValueOptions adds default value options based on type
func addDefaultValueOptions(
        propOpts []mcp.PropertyOption,
        defaultValue interface{}) []mcp.PropertyOption <span class="cov8" title="1">{
        switch val := defaultValue.(type) </span>{
        case string:<span class="cov8" title="1">
                propOpts = append(propOpts, mcp.DefaultString(val))</span>
        case float64:<span class="cov8" title="1">
                propOpts = append(propOpts, mcp.DefaultNumber(val))</span>
        case bool:<span class="cov8" title="1">
                propOpts = append(propOpts, mcp.DefaultBool(val))</span>
        }
        <span class="cov8" title="1">return propOpts</span>
}

// addEnumOptions adds enum options if present
func addEnumOptions(
        propOpts []mcp.PropertyOption,
        enumValues interface{}) []mcp.PropertyOption <span class="cov8" title="1">{
        values, ok := enumValues.([]interface{})
        if !ok </span><span class="cov8" title="1">{
                return propOpts
        }</span>

        // Convert values to strings for now
        <span class="cov8" title="1">strValues := make([]string, 0, len(values))
        for _, ev := range values </span><span class="cov8" title="1">{
                if str, ok := ev.(string); ok </span><span class="cov8" title="1">{
                        strValues = append(strValues, str)
                }</span>
        }

        <span class="cov8" title="1">if len(strValues) &gt; 0 </span><span class="cov8" title="1">{
                propOpts = append(propOpts, mcp.Enum(strValues...))
        }</span>

        <span class="cov8" title="1">return propOpts</span>
}

// addObjectPropertyOptions adds object-specific options
func addObjectPropertyOptions(
        propOpts []mcp.PropertyOption,
        schema map[string]interface{}) []mcp.PropertyOption <span class="cov8" title="1">{
        // Add maxProperties if present
        if maxProps, ok := schema["maxProperties"].(int); ok </span><span class="cov8" title="1">{
                propOpts = append(propOpts, mcp.MaxProperties(maxProps))
        }</span>

        // Add minProperties if present
        <span class="cov8" title="1">if minProps, ok := schema["minProperties"].(int); ok </span><span class="cov8" title="1">{
                propOpts = append(propOpts, mcp.MinProperties(minProps))
        }</span>

        <span class="cov8" title="1">return propOpts</span>
}

// addArrayPropertyOptions adds array-specific options
func addArrayPropertyOptions(
        propOpts []mcp.PropertyOption,
        schema map[string]interface{}) []mcp.PropertyOption <span class="cov8" title="1">{
        // Add minItems if present
        if minItems, ok := schema["minItems"].(int); ok </span><span class="cov8" title="1">{
                propOpts = append(propOpts, mcp.MinItems(minItems))
        }</span>

        // Add maxItems if present
        <span class="cov8" title="1">if maxItems, ok := schema["maxItems"].(int); ok </span><span class="cov8" title="1">{
                propOpts = append(propOpts, mcp.MaxItems(maxItems))
        }</span>

        <span class="cov8" title="1">return propOpts</span>
}

// convertSchemaToPropertyOptions converts our schema to mcp property options
func convertSchemaToPropertyOptions(
        schema map[string]interface{}) []mcp.PropertyOption <span class="cov8" title="1">{
        var propOpts []mcp.PropertyOption

        // Add description if present
        if description, ok := schema["description"].(string); ok &amp;&amp; description != "" </span><span class="cov8" title="1">{
                propOpts = append(propOpts, mcp.Description(description))
        }</span>

        // Add required flag if present
        <span class="cov8" title="1">if required, ok := schema["required"].(bool); ok &amp;&amp; required </span><span class="cov8" title="1">{
                propOpts = append(propOpts, mcp.Required())
        }</span>

        // Skip type, description and required as they're handled separately
        <span class="cov8" title="1">for k, v := range schema </span><span class="cov8" title="1">{
                if k == "type" || k == "description" || k == "required" </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Process property based on key
                <span class="cov8" title="1">switch k </span>{
                case "minimum", "maximum":<span class="cov8" title="1">
                        propOpts = addNumberPropertyOptions(propOpts, schema)</span>
                case "minLength", "maxLength", "pattern":<span class="cov8" title="1">
                        propOpts = addStringPropertyOptions(propOpts, schema)</span>
                case "default":<span class="cov8" title="1">
                        propOpts = addDefaultValueOptions(propOpts, v)</span>
                case "enum":<span class="cov8" title="1">
                        propOpts = addEnumOptions(propOpts, v)</span>
                case "maxProperties", "minProperties":<span class="cov8" title="1">
                        propOpts = addObjectPropertyOptions(propOpts, schema)</span>
                case "minItems", "maxItems":<span class="cov8" title="1">
                        propOpts = addArrayPropertyOptions(propOpts, schema)</span>
                }
        }

        <span class="cov8" title="1">return propOpts</span>
}

// GetHandler returns the handler for the tool
func (t *mark3labsToolImpl) GetHandler() ToolHandler <span class="cov8" title="1">{
        return t.handler
}</span>

// toMCPServerTool converts our Tool to mcp's ServerTool
func (t *mark3labsToolImpl) toMCPServerTool() server.ServerTool <span class="cov8" title="1">{
        // Create the mcp tool with appropriate options
        var toolOpts []mcp.ToolOption

        // Add description
        toolOpts = append(toolOpts, mcp.WithDescription(t.description))

        // Add parameters with their schemas
        for _, param := range t.parameters </span><span class="cov8" title="1">{
                // Get property options from schema
                propOpts := convertSchemaToPropertyOptions(param.Schema)

                // Get the type from the schema
                schemaType, ok := param.Schema["type"].(string)
                if !ok </span><span class="cov8" title="1">{
                        // Default to string if type is missing or not a string
                        schemaType = "string"
                }</span>

                // Use the appropriate function based on schema type
                <span class="cov8" title="1">switch schemaType </span>{
                case "string":<span class="cov8" title="1">
                        toolOpts = append(toolOpts, mcp.WithString(param.Name, propOpts...))</span>
                case "number", "integer":<span class="cov8" title="1">
                        toolOpts = append(toolOpts, mcp.WithNumber(param.Name, propOpts...))</span>
                case "boolean":<span class="cov8" title="1">
                        toolOpts = append(toolOpts, mcp.WithBoolean(param.Name, propOpts...))</span>
                case "object":<span class="cov8" title="1">
                        toolOpts = append(toolOpts, mcp.WithObject(param.Name, propOpts...))</span>
                case "array":<span class="cov8" title="1">
                        toolOpts = append(toolOpts, mcp.WithArray(param.Name, propOpts...))</span>
                default:<span class="cov8" title="1">
                        // Unknown type, default to string
                        toolOpts = append(toolOpts, mcp.WithString(param.Name, propOpts...))</span>
                }
        }

        // Create the tool with all options
        <span class="cov8" title="1">tool := mcp.NewTool(t.name, toolOpts...)

        // Create the handler
        handlerFunc := func(
                ctx context.Context,
                req mcp.CallToolRequest,
        ) (*mcp.CallToolResult, error) </span><span class="cov8" title="1">{
                // Convert mcp request to our request
                ourReq := CallToolRequest{
                        Name:      req.Params.Name,
                        Arguments: req.Params.Arguments,
                }

                // Call our handler
                result, err := t.handler(ctx, ourReq)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                // Convert our result to mcp result
                <span class="cov8" title="1">var mcpResult *mcp.CallToolResult
                if result.IsError </span><span class="cov8" title="1">{
                        mcpResult = mcp.NewToolResultError(result.Text)
                }</span> else<span class="cov0" title="0"> {
                        mcpResult = mcp.NewToolResultText(result.Text)
                }</span>

                <span class="cov8" title="1">return mcpResult, nil</span>
        }

        <span class="cov8" title="1">return server.ServerTool{
                Tool:    tool,
                Handler: handlerFunc,
        }</span>
}

// NewToolResultJSON creates a new tool result with JSON content
func NewToolResultJSON(data interface{}) (*ToolResult, error) <span class="cov8" title="1">{
        jsonBytes, err := json.Marshal(data)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;ToolResult{
                Text:    string(jsonBytes),
                IsError: false,
                Content: nil,
        }, nil</span>
}

// NewToolResultText creates a new tool result with text content
func NewToolResultText(text string) *ToolResult <span class="cov8" title="1">{
        return &amp;ToolResult{
                Text:    text,
                IsError: false,
                Content: nil,
        }
}</span>

// NewToolResultError creates a new tool result with an error
func NewToolResultError(text string) *ToolResult <span class="cov8" title="1">{
        return &amp;ToolResult{
                Text:    text,
                IsError: true,
                Content: nil,
        }
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package observability

import (
        "github.com/razorpay/razorpay-mcp-server/pkg/log"
)

// Option is used make Observability
type Option func(*Observability)

// Observability holds all the observability related dependencies
type Observability struct {
        // Logger will be passed as dependency to other services
        // which will help in pushing logs
        Logger log.Logger
}

// New will create a new Observability object and
// apply all the options to that object and returns pointer to the object
func New(opts ...Option) *Observability <span class="cov8" title="1">{
        observability := &amp;Observability{}
        // Loop through each option
        for _, opt := range opts </span><span class="cov8" title="1">{
                opt(observability)
        }</span>
        <span class="cov8" title="1">return observability</span>
}

// WithLoggingService will set the logging dependency in Deps
func WithLoggingService(s log.Logger) Option <span class="cov8" title="1">{
        return func(observe *Observability) </span><span class="cov8" title="1">{
                observe.Logger = s
        }</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package mock

import (
        "encoding/json"
        "fmt"
        "net/http"
        "net/http/httptest"

        "github.com/gorilla/mux"
)

// Endpoint defines a route and its response
type Endpoint struct {
        Path     string
        Method   string
        Response interface{}
}

// NewHTTPClient creates and returns a mock HTTP client with configured
// endpoints
func NewHTTPClient(
        endpoints ...Endpoint,
) (*http.Client, *httptest.Server) <span class="cov8" title="1">{
        mockServer := NewServer(endpoints...)
        client := mockServer.Client()
        return client, mockServer
}</span>

// NewServer creates a mock HTTP server for testing
func NewServer(endpoints ...Endpoint) *httptest.Server <span class="cov8" title="1">{
        router := mux.NewRouter()

        for _, endpoint := range endpoints </span><span class="cov8" title="1">{
                path := endpoint.Path
                method := endpoint.Method
                response := endpoint.Response

                router.HandleFunc(path, func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        w.Header().Set("Content-Type", "application/json")

                        if respMap, ok := response.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                if _, hasError := respMap["error"]; hasError </span><span class="cov8" title="1">{
                                        w.WriteHeader(http.StatusBadRequest)
                                }</span> else<span class="cov8" title="1"> {
                                        w.WriteHeader(http.StatusOK)
                                }</span>
                        } else<span class="cov8" title="1"> {
                                w.WriteHeader(http.StatusOK)
                        }</span>

                        <span class="cov8" title="1">switch resp := response.(type) </span>{
                        case []byte:<span class="cov8" title="1">
                                _, err := w.Write(resp)
                                if err != nil </span><span class="cov0" title="0">{
                                        http.Error(w, err.Error(), http.StatusInternalServerError)
                                }</span>
                        case string:<span class="cov8" title="1">
                                _, err := w.Write([]byte(resp))
                                if err != nil </span><span class="cov0" title="0">{
                                        http.Error(w, err.Error(), http.StatusInternalServerError)
                                }</span>
                        default:<span class="cov8" title="1">
                                err := json.NewEncoder(w).Encode(resp)
                                if err != nil </span><span class="cov0" title="0">{
                                        http.Error(w, err.Error(), http.StatusInternalServerError)
                                }</span>
                        }
                }).Methods(method)
        }

        <span class="cov8" title="1">router.NotFoundHandler = http.HandlerFunc(
                func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        w.Header().Set("Content-Type", "application/json")
                        w.WriteHeader(http.StatusNotFound)

                        _ = json.NewEncoder(w).Encode(map[string]interface{}{
                                "error": map[string]interface{}{
                                        "code":        "NOT_FOUND",
                                        "description": fmt.Sprintf("No mock for %s %s", r.Method, r.URL.Path),
                                },
                        })
                }</span>)

        <span class="cov8" title="1">return httptest.NewServer(router)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package razorpay

import (
        "context"
        "fmt"

        rzpsdk "github.com/razorpay/razorpay-go"

        "github.com/razorpay/razorpay-mcp-server/pkg/mcpgo"
        "github.com/razorpay/razorpay-mcp-server/pkg/observability"
)

// CreateOrder returns a tool that creates new orders in Razorpay
func CreateOrder(
        obs *observability.Observability,
        client *rzpsdk.Client,
) mcpgo.Tool <span class="cov8" title="1">{
        parameters := []mcpgo.ToolParameter{
                mcpgo.WithNumber(
                        "amount",
                        mcpgo.Description("Payment amount in the smallest "+
                                "currency sub-unit (e.g., for 295, use 29500)"),
                        mcpgo.Required(),
                        mcpgo.Min(100), // Minimum amount is 100 (1.00 in currency)
                ),
                mcpgo.WithString(
                        "currency",
                        mcpgo.Description("ISO code for the currency "+
                                "(e.g., INR, USD, SGD)"),
                        mcpgo.Required(),
                        mcpgo.Pattern("^[A-Z]{3}$"), // ISO currency codes are 3 uppercase letters
                ),
                mcpgo.WithString(
                        "receipt",
                        mcpgo.Description("Receipt number for internal "+
                                "reference (max 40 chars, must be unique)"),
                        mcpgo.Max(40),
                ),
                mcpgo.WithObject(
                        "notes",
                        mcpgo.Description("Key-value pairs for additional "+
                                "information (max 15 pairs, 256 chars each)"),
                        mcpgo.MaxProperties(15),
                ),
                mcpgo.WithBoolean(
                        "partial_payment",
                        mcpgo.Description("Whether the customer can make partial payments"),
                        mcpgo.DefaultValue(false),
                ),
                mcpgo.WithNumber(
                        "first_payment_min_amount",
                        mcpgo.Description("Minimum amount for first partial "+
                                "payment (only if partial_payment is true)"),
                        mcpgo.Min(100),
                ),
                mcpgo.WithArray(
                        "transfers",
                        mcpgo.Description("Array of transfer objects for distributing "+
                                "payment amounts among multiple linked accounts. Each transfer "+
                                "object should contain: account (linked account ID), amount "+
                                "(in currency subunits), currency (ISO code), and optional fields "+
                                "like notes, linked_account_notes, on_hold, on_hold_until"),
                ),
                mcpgo.WithString(
                        "method",
                        mcpgo.Description("Payment method for mandate orders. "+
                                "REQUIRED for mandate orders. Must be 'upi' when using "+
                                "token.type='single_block_multiple_debit'. This field is used "+
                                "only for mandate/recurring payment orders."),
                ),
                mcpgo.WithString(
                        "customer_id",
                        mcpgo.Description("Customer ID for mandate orders. "+
                                "REQUIRED for mandate orders. Must start with 'cust_' followed by "+
                                "alphanumeric characters. Example: 'cust_xxx'. "+
                                "This identifies the customer for recurring payments."),
                ),
                mcpgo.WithObject(
                        "token",
                        mcpgo.Description("Token object for mandate orders. "+
                                "REQUIRED for mandate orders. Must contain: max_amount "+
                                "(positive number, maximum debit amount), frequency "+
                                "(as_presented/monthly/one_time/yearly/weekly/daily), "+
                                "type='single_block_multiple_debit' (only supported type), "+
                                "and optionally expire_at (Unix timestamp, defaults to today+60days). "+
                                "Example: {\"max_amount\": 100, \"frequency\": \"as_presented\", "+
                                "\"type\": \"single_block_multiple_debit\"}"),
                ),
        }

        handler := func(
                ctx context.Context,
                r mcpgo.CallToolRequest,
        ) (*mcpgo.ToolResult, error) </span><span class="cov8" title="1">{
                // Get client from context or use default
                client, err := getClientFromContextOrDefault(ctx, client)
                if err != nil </span><span class="cov0" title="0">{
                        return mcpgo.NewToolResultError(err.Error()), nil
                }</span>

                <span class="cov8" title="1">payload := make(map[string]interface{})

                validator := NewValidator(&amp;r).
                        ValidateAndAddRequiredFloat(payload, "amount").
                        ValidateAndAddRequiredString(payload, "currency").
                        ValidateAndAddOptionalString(payload, "receipt").
                        ValidateAndAddOptionalMap(payload, "notes").
                        ValidateAndAddOptionalBool(payload, "partial_payment").
                        ValidateAndAddOptionalArray(payload, "transfers").
                        ValidateAndAddOptionalString(payload, "method").
                        ValidateAndAddOptionalString(payload, "customer_id").
                        ValidateAndAddToken(payload, "token")

                // Add first_payment_min_amount only if partial_payment is true
                if payload["partial_payment"] == true </span><span class="cov8" title="1">{
                        validator.ValidateAndAddOptionalFloat(payload, "first_payment_min_amount")
                }</span>

                <span class="cov8" title="1">if result, err := validator.HandleErrorsIfAny(); result != nil </span><span class="cov8" title="1">{
                        return result, err
                }</span>

                <span class="cov8" title="1">order, err := client.Order.Create(payload, nil)
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(
                                fmt.Sprintf("creating order failed: %s", err.Error()),
                        ), nil
                }</span>

                <span class="cov8" title="1">return mcpgo.NewToolResultJSON(order)</span>
        }

        <span class="cov8" title="1">return mcpgo.NewTool(
                "create_order",
                "Create a new order in Razorpay. Supports both regular orders and "+
                        "mandate orders. "+
                        "\n\nFor REGULAR ORDERS: Provide amount, currency, and optional "+
                        "receipt/notes. "+
                        "\n\nFor MANDATE ORDERS (recurring payments): You MUST provide ALL "+
                        "of these fields: "+
                        "amount, currency, method='upi', customer_id (starts with 'cust_'), "+
                        "and token object. "+
                        "\n\nThe token object is required for mandate orders and must contain: "+
                        "max_amount (positive number), frequency "+
                        "(as_presented/monthly/one_time/yearly/weekly/daily), "+
                        "type='single_block_multiple_debit', and optionally expire_at "+
                        "(defaults to today+60days). "+
                        "\n\nIMPORTANT: When token.type is 'single_block_multiple_debit', "+
                        "the method MUST be 'upi'. "+
                        "\n\nExample mandate order payload: "+
                        `{"amount": 100, "currency": "INR", "method": "upi", `+
                        `"customer_id": "cust_abc123", `+
                        `"token": {"max_amount": 100, "frequency": "as_presented", `+
                        `"type": "single_block_multiple_debit"}, `+
                        `"receipt": "Receipt No. 1", "notes": {"key": "value"}}`,
                parameters,
                handler,
        )</span>
}

// FetchOrder returns a tool to fetch order details by ID
func FetchOrder(
        obs *observability.Observability,
        client *rzpsdk.Client,
) mcpgo.Tool <span class="cov8" title="1">{
        parameters := []mcpgo.ToolParameter{
                mcpgo.WithString(
                        "order_id",
                        mcpgo.Description("Unique identifier of the order to be retrieved"),
                        mcpgo.Required(),
                ),
        }

        handler := func(
                ctx context.Context,
                r mcpgo.CallToolRequest,
        ) (*mcpgo.ToolResult, error) </span><span class="cov8" title="1">{
                // Get client from context or use default
                client, err := getClientFromContextOrDefault(ctx, client)
                if err != nil </span><span class="cov0" title="0">{
                        return mcpgo.NewToolResultError(err.Error()), nil
                }</span>

                <span class="cov8" title="1">payload := make(map[string]interface{})

                validator := NewValidator(&amp;r).
                        ValidateAndAddRequiredString(payload, "order_id")

                if result, err := validator.HandleErrorsIfAny(); result != nil </span><span class="cov8" title="1">{
                        return result, err
                }</span>

                <span class="cov8" title="1">order, err := client.Order.Fetch(payload["order_id"].(string), nil, nil)
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(
                                fmt.Sprintf("fetching order failed: %s", err.Error()),
                        ), nil
                }</span>

                <span class="cov8" title="1">return mcpgo.NewToolResultJSON(order)</span>
        }

        <span class="cov8" title="1">return mcpgo.NewTool(
                "fetch_order",
                "Fetch an order's details using its ID",
                parameters,
                handler,
        )</span>
}

// FetchAllOrders returns a tool to fetch all orders with optional filtering
func FetchAllOrders(
        obs *observability.Observability,
        client *rzpsdk.Client,
) mcpgo.Tool <span class="cov8" title="1">{
        parameters := []mcpgo.ToolParameter{
                mcpgo.WithNumber(
                        "count",
                        mcpgo.Description("Number of orders to be fetched "+
                                "(default: 10, max: 100)"),
                        mcpgo.Min(1),
                        mcpgo.Max(100),
                ),
                mcpgo.WithNumber(
                        "skip",
                        mcpgo.Description("Number of orders to be skipped (default: 0)"),
                        mcpgo.Min(0),
                ),
                mcpgo.WithNumber(
                        "from",
                        mcpgo.Description("Timestamp (in Unix format) from when "+
                                "the orders should be fetched"),
                        mcpgo.Min(0),
                ),
                mcpgo.WithNumber(
                        "to",
                        mcpgo.Description("Timestamp (in Unix format) up till "+
                                "when orders are to be fetched"),
                        mcpgo.Min(0),
                ),
                mcpgo.WithNumber(
                        "authorized",
                        mcpgo.Description("Filter orders based on payment authorization status. "+
                                "Values: 0 (orders with unauthorized payments), "+
                                "1 (orders with authorized payments)"),
                        mcpgo.Min(0),
                        mcpgo.Max(1),
                ),
                mcpgo.WithString(
                        "receipt",
                        mcpgo.Description("Filter orders that contain the "+
                                "provided value for receipt"),
                ),
                mcpgo.WithArray(
                        "expand",
                        mcpgo.Description("Used to retrieve additional information. "+
                                "Supported values: payments, payments.card, transfers, virtual_account"),
                ),
        }

        handler := func(
                ctx context.Context,
                r mcpgo.CallToolRequest,
        ) (*mcpgo.ToolResult, error) </span><span class="cov8" title="1">{
                // Get client from context or use default
                client, err := getClientFromContextOrDefault(ctx, client)
                if err != nil </span><span class="cov0" title="0">{
                        return mcpgo.NewToolResultError(err.Error()), nil
                }</span>

                <span class="cov8" title="1">queryParams := make(map[string]interface{})

                validator := NewValidator(&amp;r).
                        ValidateAndAddPagination(queryParams).
                        ValidateAndAddOptionalInt(queryParams, "from").
                        ValidateAndAddOptionalInt(queryParams, "to").
                        ValidateAndAddOptionalInt(queryParams, "authorized").
                        ValidateAndAddOptionalString(queryParams, "receipt").
                        ValidateAndAddExpand(queryParams)

                if result, err := validator.HandleErrorsIfAny(); result != nil </span><span class="cov8" title="1">{
                        return result, err
                }</span>

                <span class="cov8" title="1">orders, err := client.Order.All(queryParams, nil)
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(
                                fmt.Sprintf("fetching orders failed: %s", err.Error()),
                        ), nil
                }</span>

                <span class="cov8" title="1">return mcpgo.NewToolResultJSON(orders)</span>
        }

        <span class="cov8" title="1">return mcpgo.NewTool(
                "fetch_all_orders",
                "Fetch all orders with optional filtering and pagination",
                parameters,
                handler,
        )</span>
}

// FetchOrderPayments returns a tool to fetch all payments for a specific order
func FetchOrderPayments(
        obs *observability.Observability,
        client *rzpsdk.Client,
) mcpgo.Tool <span class="cov8" title="1">{
        parameters := []mcpgo.ToolParameter{
                mcpgo.WithString(
                        "order_id",
                        mcpgo.Description(
                                "Unique identifier of the order for which payments should"+
                                        " be retrieved. Order id should start with `order_`"),
                        mcpgo.Required(),
                ),
        }

        handler := func(
                ctx context.Context,
                r mcpgo.CallToolRequest,
        ) (*mcpgo.ToolResult, error) </span><span class="cov8" title="1">{
                // Get client from context or use default
                client, err := getClientFromContextOrDefault(ctx, client)
                if err != nil </span><span class="cov0" title="0">{
                        return mcpgo.NewToolResultError(err.Error()), nil
                }</span>

                <span class="cov8" title="1">orderPaymentsReq := make(map[string]interface{})

                validator := NewValidator(&amp;r).
                        ValidateAndAddRequiredString(orderPaymentsReq, "order_id")

                if result, err := validator.HandleErrorsIfAny(); result != nil </span><span class="cov8" title="1">{
                        return result, err
                }</span>

                // Fetch payments for the order using Razorpay SDK
                // Note: Using the Order.Payments method from SDK
                <span class="cov8" title="1">orderID := orderPaymentsReq["order_id"].(string)
                payments, err := client.Order.Payments(orderID, nil, nil)
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(
                                fmt.Sprintf(
                                        "fetching payments for order failed: %s",
                                        err.Error(),
                                ),
                        ), nil
                }</span>

                // Return the result as JSON
                <span class="cov8" title="1">return mcpgo.NewToolResultJSON(payments)</span>
        }

        <span class="cov8" title="1">return mcpgo.NewTool(
                "fetch_order_payments",
                "Fetch all payments made for a specific order in Razorpay",
                parameters,
                handler,
        )</span>
}

// UpdateOrder returns a tool to update an order
// only the order's notes can be updated
func UpdateOrder(
        obs *observability.Observability,
        client *rzpsdk.Client,
) mcpgo.Tool <span class="cov8" title="1">{
        parameters := []mcpgo.ToolParameter{
                mcpgo.WithString(
                        "order_id",
                        mcpgo.Description("Unique identifier of the order which "+
                                "needs to be updated. ID should have an order_ prefix."),
                        mcpgo.Required(),
                ),
                mcpgo.WithObject(
                        "notes",
                        mcpgo.Description("Key-value pairs used to store additional "+
                                "information about the order. A maximum of 15 key-value pairs "+
                                "can be included, with each value not exceeding 256 characters."),
                        mcpgo.Required(),
                ),
        }

        handler := func(
                ctx context.Context,
                r mcpgo.CallToolRequest,
        ) (*mcpgo.ToolResult, error) </span><span class="cov8" title="1">{
                orderUpdateReq := make(map[string]interface{})
                data := make(map[string]interface{})

                client, err := getClientFromContextOrDefault(ctx, client)
                if err != nil </span><span class="cov0" title="0">{
                        return mcpgo.NewToolResultError(err.Error()), nil
                }</span>

                <span class="cov8" title="1">validator := NewValidator(&amp;r).
                        ValidateAndAddRequiredString(orderUpdateReq, "order_id").
                        ValidateAndAddRequiredMap(orderUpdateReq, "notes")

                if result, err := validator.HandleErrorsIfAny(); result != nil </span><span class="cov8" title="1">{
                        return result, err
                }</span>

                <span class="cov8" title="1">data["notes"] = orderUpdateReq["notes"]
                orderID := orderUpdateReq["order_id"].(string)

                order, err := client.Order.Update(orderID, data, nil)
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(
                                fmt.Sprintf("updating order failed: %s", err.Error())), nil
                }</span>

                <span class="cov8" title="1">return mcpgo.NewToolResultJSON(order)</span>
        }

        <span class="cov8" title="1">return mcpgo.NewTool(
                "update_order",
                "Use this tool to update the notes for a specific order. "+
                        "Only the notes field can be modified.",
                parameters,
                handler,
        )</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package razorpay

import (
        "context"
        "fmt"

        rzpsdk "github.com/razorpay/razorpay-go"

        "github.com/razorpay/razorpay-mcp-server/pkg/mcpgo"
        "github.com/razorpay/razorpay-mcp-server/pkg/observability"
)

// CreatePaymentLink returns a tool that creates payment links in Razorpay
func CreatePaymentLink(
        obs *observability.Observability,
        client *rzpsdk.Client,
) mcpgo.Tool <span class="cov8" title="1">{
        parameters := []mcpgo.ToolParameter{
                mcpgo.WithNumber(
                        "amount",
                        mcpgo.Description("Amount to be paid using the link in smallest "+
                                "currency unit(e.g., 300, use 30000)"),
                        mcpgo.Required(),
                        mcpgo.Min(100), // Minimum amount is 100 (1.00 in currency)
                ),
                mcpgo.WithString(
                        "currency",
                        mcpgo.Description("Three-letter ISO code for the currency (e.g., INR)"),
                        mcpgo.Required(),
                ),
                mcpgo.WithString(
                        "description",
                        mcpgo.Description("A brief description of the Payment Link explaining the intent of the payment."), // nolint:lll
                ),
                mcpgo.WithBoolean(
                        "accept_partial",
                        mcpgo.Description("Indicates whether customers can make partial payments using the Payment Link. Default: false"), // nolint:lll
                ),
                mcpgo.WithNumber(
                        "first_min_partial_amount",
                        mcpgo.Description("Minimum amount that must be paid by the customer as the first partial payment. Default value is 100."), // nolint:lll
                ),
                mcpgo.WithNumber(
                        "expire_by",
                        mcpgo.Description("Timestamp, in Unix, when the Payment Link will expire. By default, a Payment Link will be valid for six months."), // nolint:lll
                ),
                mcpgo.WithString(
                        "reference_id",
                        mcpgo.Description("Reference number tagged to a Payment Link. Must be unique for each Payment Link. Max 40 characters."), // nolint:lll
                ),
                mcpgo.WithString(
                        "customer_name",
                        mcpgo.Description("Name of the customer."),
                ),
                mcpgo.WithString(
                        "customer_email",
                        mcpgo.Description("Email address of the customer."),
                ),
                mcpgo.WithString(
                        "customer_contact",
                        mcpgo.Description("Contact number of the customer."),
                ),
                mcpgo.WithBoolean(
                        "notify_sms",
                        mcpgo.Description("Send SMS notifications for the Payment Link."),
                ),
                mcpgo.WithBoolean(
                        "notify_email",
                        mcpgo.Description("Send email notifications for the Payment Link."),
                ),
                mcpgo.WithBoolean(
                        "reminder_enable",
                        mcpgo.Description("Enable payment reminders for the Payment Link."),
                ),
                mcpgo.WithObject(
                        "notes",
                        mcpgo.Description("Key-value pairs that can be used to store additional information. Maximum 15 pairs, each value limited to 256 characters."), // nolint:lll
                ),
                mcpgo.WithString(
                        "callback_url",
                        mcpgo.Description("If specified, adds a redirect URL to the Payment Link. Customer will be redirected here after payment."), // nolint:lll
                ),
                mcpgo.WithString(
                        "callback_method",
                        mcpgo.Description("HTTP method for callback redirection. "+
                                "Must be 'get' if callback_url is set."),
                ),
        }

        handler := func(
                ctx context.Context,
                r mcpgo.CallToolRequest,
        ) (*mcpgo.ToolResult, error) </span><span class="cov8" title="1">{
                // Get client from context or use default
                client, err := getClientFromContextOrDefault(ctx, client)
                if err != nil </span><span class="cov0" title="0">{
                        return mcpgo.NewToolResultError(err.Error()), nil
                }</span>

                // Create a parameters map to collect validated parameters
                <span class="cov8" title="1">plCreateReq := make(map[string]interface{})
                customer := make(map[string]interface{})
                notify := make(map[string]interface{})
                // Validate all parameters with fluent validator
                validator := NewValidator(&amp;r).
                        ValidateAndAddRequiredInt(plCreateReq, "amount").
                        ValidateAndAddRequiredString(plCreateReq, "currency").
                        ValidateAndAddOptionalString(plCreateReq, "description").
                        ValidateAndAddOptionalBool(plCreateReq, "accept_partial").
                        ValidateAndAddOptionalInt(plCreateReq, "first_min_partial_amount").
                        ValidateAndAddOptionalInt(plCreateReq, "expire_by").
                        ValidateAndAddOptionalString(plCreateReq, "reference_id").
                        ValidateAndAddOptionalStringToPath(customer, "customer_name", "name").
                        ValidateAndAddOptionalStringToPath(customer, "customer_email", "email").
                        ValidateAndAddOptionalStringToPath(customer, "customer_contact", "contact").
                        ValidateAndAddOptionalBoolToPath(notify, "notify_sms", "sms").
                        ValidateAndAddOptionalBoolToPath(notify, "notify_email", "email").
                        ValidateAndAddOptionalBool(plCreateReq, "reminder_enable").
                        ValidateAndAddOptionalMap(plCreateReq, "notes").
                        ValidateAndAddOptionalString(plCreateReq, "callback_url").
                        ValidateAndAddOptionalString(plCreateReq, "callback_method")

                if result, err := validator.HandleErrorsIfAny(); result != nil </span><span class="cov8" title="1">{
                        return result, err
                }</span>

                // Handle customer details
                <span class="cov8" title="1">if len(customer) &gt; 0 </span><span class="cov0" title="0">{
                        plCreateReq["customer"] = customer
                }</span>

                // Handle notification settings
                <span class="cov8" title="1">if len(notify) &gt; 0 </span><span class="cov0" title="0">{
                        plCreateReq["notify"] = notify
                }</span>

                // Create the payment link
                <span class="cov8" title="1">paymentLink, err := client.PaymentLink.Create(plCreateReq, nil)
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(
                                fmt.Sprintf("creating payment link failed: %s", err.Error())), nil
                }</span>

                <span class="cov8" title="1">return mcpgo.NewToolResultJSON(paymentLink)</span>
        }

        <span class="cov8" title="1">return mcpgo.NewTool(
                "create_payment_link",
                "Create a new standard payment link in Razorpay with a specified amount",
                parameters,
                handler,
        )</span>
}

// CreateUpiPaymentLink returns a tool that creates payment links in Razorpay
func CreateUpiPaymentLink(
        obs *observability.Observability,
        client *rzpsdk.Client,
) mcpgo.Tool <span class="cov8" title="1">{
        parameters := []mcpgo.ToolParameter{
                mcpgo.WithNumber(
                        "amount",
                        mcpgo.Description("Amount to be paid using the link in smallest currency unit(e.g., 300, use 30000), Only accepted currency is INR"), // nolint:lll
                        mcpgo.Required(),
                        mcpgo.Min(100), // Minimum amount is 100 (1.00 in currency)
                ),
                mcpgo.WithString(
                        "currency",
                        mcpgo.Description("Three-letter ISO code for the currency (e.g., INR). UPI links are only supported in INR"), // nolint:lll
                        mcpgo.Required(),
                ),
                mcpgo.WithString(
                        "description",
                        mcpgo.Description("A brief description of the Payment Link explaining the intent of the payment."), // nolint:lll
                ),
                mcpgo.WithBoolean(
                        "accept_partial",
                        mcpgo.Description("Indicates whether customers can make partial payments using the Payment Link. Default: false"), // nolint:lll
                ),
                mcpgo.WithNumber(
                        "first_min_partial_amount",
                        mcpgo.Description("Minimum amount that must be paid by the customer as the first partial payment. Default value is 100."), // nolint:lll
                ),
                mcpgo.WithNumber(
                        "expire_by",
                        mcpgo.Description("Timestamp, in Unix, when the Payment Link will expire. By default, a Payment Link will be valid for six months."), // nolint:lll
                ),
                mcpgo.WithString(
                        "reference_id",
                        mcpgo.Description("Reference number tagged to a Payment Link. Must be unique for each Payment Link. Max 40 characters."), // nolint:lll
                ),
                mcpgo.WithString(
                        "customer_name",
                        mcpgo.Description("Name of the customer."),
                ),
                mcpgo.WithString(
                        "customer_email",
                        mcpgo.Description("Email address of the customer."),
                ),
                mcpgo.WithString(
                        "customer_contact",
                        mcpgo.Description("Contact number of the customer."),
                ),
                mcpgo.WithBoolean(
                        "notify_sms",
                        mcpgo.Description("Send SMS notifications for the Payment Link."),
                ),
                mcpgo.WithBoolean(
                        "notify_email",
                        mcpgo.Description("Send email notifications for the Payment Link."),
                ),
                mcpgo.WithBoolean(
                        "reminder_enable",
                        mcpgo.Description("Enable payment reminders for the Payment Link."),
                ),
                mcpgo.WithObject(
                        "notes",
                        mcpgo.Description("Key-value pairs that can be used to store additional information. Maximum 15 pairs, each value limited to 256 characters."), // nolint:lll
                ),
                mcpgo.WithString(
                        "callback_url",
                        mcpgo.Description("If specified, adds a redirect URL to the Payment Link. Customer will be redirected here after payment."), // nolint:lll
                ),
                mcpgo.WithString(
                        "callback_method",
                        mcpgo.Description("HTTP method for callback redirection. "+
                                "Must be 'get' if callback_url is set."),
                ),
        }

        handler := func(
                ctx context.Context,
                r mcpgo.CallToolRequest,
        ) (*mcpgo.ToolResult, error) </span><span class="cov8" title="1">{
                // Create a parameters map to collect validated parameters
                upiPlCreateReq := make(map[string]interface{})
                customer := make(map[string]interface{})
                notify := make(map[string]interface{})
                // Validate all parameters with fluent validator
                validator := NewValidator(&amp;r).
                        ValidateAndAddRequiredInt(upiPlCreateReq, "amount").
                        ValidateAndAddRequiredString(upiPlCreateReq, "currency").
                        ValidateAndAddOptionalString(upiPlCreateReq, "description").
                        ValidateAndAddOptionalBool(upiPlCreateReq, "accept_partial").
                        ValidateAndAddOptionalInt(upiPlCreateReq, "first_min_partial_amount").
                        ValidateAndAddOptionalInt(upiPlCreateReq, "expire_by").
                        ValidateAndAddOptionalString(upiPlCreateReq, "reference_id").
                        ValidateAndAddOptionalStringToPath(customer, "customer_name", "name").
                        ValidateAndAddOptionalStringToPath(customer, "customer_email", "email").
                        ValidateAndAddOptionalStringToPath(customer, "customer_contact", "contact").
                        ValidateAndAddOptionalBoolToPath(notify, "notify_sms", "sms").
                        ValidateAndAddOptionalBoolToPath(notify, "notify_email", "email").
                        ValidateAndAddOptionalBool(upiPlCreateReq, "reminder_enable").
                        ValidateAndAddOptionalMap(upiPlCreateReq, "notes").
                        ValidateAndAddOptionalString(upiPlCreateReq, "callback_url").
                        ValidateAndAddOptionalString(upiPlCreateReq, "callback_method")

                if result, err := validator.HandleErrorsIfAny(); result != nil </span><span class="cov8" title="1">{
                        return result, err
                }</span>

                // Add the required UPI payment link parameters
                <span class="cov8" title="1">upiPlCreateReq["upi_link"] = "true"

                // Handle customer details
                if len(customer) &gt; 0 </span><span class="cov8" title="1">{
                        upiPlCreateReq["customer"] = customer
                }</span>

                // Handle notification settings
                <span class="cov8" title="1">if len(notify) &gt; 0 </span><span class="cov8" title="1">{
                        upiPlCreateReq["notify"] = notify
                }</span>

                <span class="cov8" title="1">client, err := getClientFromContextOrDefault(ctx, client)
                if err != nil </span><span class="cov0" title="0">{
                        return mcpgo.NewToolResultError(err.Error()), nil
                }</span>

                // Create the payment link
                <span class="cov8" title="1">paymentLink, err := client.PaymentLink.Create(upiPlCreateReq, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return mcpgo.NewToolResultError(
                                fmt.Sprintf("upi pl create failed: %s", err.Error())), nil
                }</span>

                <span class="cov8" title="1">return mcpgo.NewToolResultJSON(paymentLink)</span>
        }

        <span class="cov8" title="1">return mcpgo.NewTool(
                "payment_link_upi_create",
                "Create a new UPI payment link in Razorpay with a specified amount and additional options.", // nolint:lll
                parameters,
                handler,
        )</span>
}

// FetchPaymentLink returns a tool that fetches payment link details using
// payment_link_id
func FetchPaymentLink(
        obs *observability.Observability,
        client *rzpsdk.Client,
) mcpgo.Tool <span class="cov8" title="1">{
        parameters := []mcpgo.ToolParameter{
                mcpgo.WithString(
                        "payment_link_id",
                        mcpgo.Description("ID of the payment link to be fetched"+
                                "(ID should have a plink_ prefix)."),
                        mcpgo.Required(),
                ),
        }

        handler := func(
                ctx context.Context,
                r mcpgo.CallToolRequest,
        ) (*mcpgo.ToolResult, error) </span><span class="cov8" title="1">{
                // Get client from context or use default
                client, err := getClientFromContextOrDefault(ctx, client)
                if err != nil </span><span class="cov0" title="0">{
                        return mcpgo.NewToolResultError(err.Error()), nil
                }</span>

                <span class="cov8" title="1">fields := make(map[string]interface{})

                validator := NewValidator(&amp;r).
                        ValidateAndAddRequiredString(fields, "payment_link_id")

                if result, err := validator.HandleErrorsIfAny(); result != nil </span><span class="cov8" title="1">{
                        return result, err
                }</span>

                <span class="cov8" title="1">paymentLinkId := fields["payment_link_id"].(string)

                paymentLink, err := client.PaymentLink.Fetch(paymentLinkId, nil, nil)
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(
                                fmt.Sprintf("fetching payment link failed: %s", err.Error())), nil
                }</span>

                <span class="cov8" title="1">return mcpgo.NewToolResultJSON(paymentLink)</span>
        }

        <span class="cov8" title="1">return mcpgo.NewTool(
                "fetch_payment_link",
                "Fetch payment link details using it's ID. "+
                        "Response contains the basic details like amount, status etc. "+
                        "The link could be of any type(standard or UPI)",
                parameters,
                handler,
        )</span>
}

// ResendPaymentLinkNotification returns a tool that sends/resends notifications
// for a payment link via email or SMS
func ResendPaymentLinkNotification(
        obs *observability.Observability,
        client *rzpsdk.Client,
) mcpgo.Tool <span class="cov8" title="1">{
        parameters := []mcpgo.ToolParameter{
                mcpgo.WithString(
                        "payment_link_id",
                        mcpgo.Description("ID of the payment link for which to send notification "+
                                "(ID should have a plink_ prefix)."), // nolint:lll
                        mcpgo.Required(),
                ),
                mcpgo.WithString(
                        "medium",
                        mcpgo.Description("Medium through which to send the notification. "+
                                "Must be either 'sms' or 'email'."), // nolint:lll
                        mcpgo.Required(),
                        mcpgo.Enum("sms", "email"),
                ),
        }

        handler := func(
                ctx context.Context,
                r mcpgo.CallToolRequest,
        ) (*mcpgo.ToolResult, error) </span><span class="cov8" title="1">{
                client, err := getClientFromContextOrDefault(ctx, client)
                if err != nil </span><span class="cov0" title="0">{
                        return mcpgo.NewToolResultError(err.Error()), nil
                }</span>

                <span class="cov8" title="1">fields := make(map[string]interface{})

                validator := NewValidator(&amp;r).
                        ValidateAndAddRequiredString(fields, "payment_link_id").
                        ValidateAndAddRequiredString(fields, "medium")

                if result, err := validator.HandleErrorsIfAny(); result != nil </span><span class="cov8" title="1">{
                        return result, err
                }</span>

                <span class="cov8" title="1">paymentLinkId := fields["payment_link_id"].(string)
                medium := fields["medium"].(string)

                // Call the SDK function
                response, err := client.PaymentLink.NotifyBy(paymentLinkId, medium, nil, nil)
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(
                                fmt.Sprintf("sending notification failed: %s", err.Error())), nil
                }</span>

                <span class="cov8" title="1">return mcpgo.NewToolResultJSON(response)</span>
        }

        <span class="cov8" title="1">return mcpgo.NewTool(
                "payment_link_notify",
                "Send or resend notification for a payment link via SMS or email.", // nolint:lll
                parameters,
                handler,
        )</span>
}

// UpdatePaymentLink returns a tool that updates an existing payment link
func UpdatePaymentLink(
        obs *observability.Observability,
        client *rzpsdk.Client,
) mcpgo.Tool <span class="cov8" title="1">{
        parameters := []mcpgo.ToolParameter{
                mcpgo.WithString(
                        "payment_link_id",
                        mcpgo.Description("ID of the payment link to update "+
                                "(ID should have a plink_ prefix)."),
                        mcpgo.Required(),
                ),
                mcpgo.WithString(
                        "reference_id",
                        mcpgo.Description("Adds a unique reference number to the payment link."),
                ),
                mcpgo.WithNumber(
                        "expire_by",
                        mcpgo.Description("Timestamp, in Unix format, when the payment link "+
                                "should expire."),
                ),
                mcpgo.WithBoolean(
                        "reminder_enable",
                        mcpgo.Description("Enable or disable reminders for the payment link."),
                ),
                mcpgo.WithBoolean(
                        "accept_partial",
                        mcpgo.Description("Allow customers to make partial payments. "+
                                "Not allowed with UPI payment links."),
                ),
                mcpgo.WithObject(
                        "notes",
                        mcpgo.Description("Key-value pairs for additional information. "+
                                "Maximum 15 pairs, each value limited to 256 characters."),
                ),
        }

        handler := func(
                ctx context.Context,
                r mcpgo.CallToolRequest,
        ) (*mcpgo.ToolResult, error) </span><span class="cov8" title="1">{
                client, err := getClientFromContextOrDefault(ctx, client)
                if err != nil </span><span class="cov0" title="0">{
                        return mcpgo.NewToolResultError(err.Error()), nil
                }</span>

                <span class="cov8" title="1">plUpdateReq := make(map[string]interface{})
                otherFields := make(map[string]interface{})

                validator := NewValidator(&amp;r).
                        ValidateAndAddRequiredString(otherFields, "payment_link_id").
                        ValidateAndAddOptionalString(plUpdateReq, "reference_id").
                        ValidateAndAddOptionalInt(plUpdateReq, "expire_by").
                        ValidateAndAddOptionalBool(plUpdateReq, "reminder_enable").
                        ValidateAndAddOptionalBool(plUpdateReq, "accept_partial").
                        ValidateAndAddOptionalMap(plUpdateReq, "notes")

                if result, err := validator.HandleErrorsIfAny(); result != nil </span><span class="cov8" title="1">{
                        return result, err
                }</span>

                <span class="cov8" title="1">paymentLinkId := otherFields["payment_link_id"].(string)

                // Ensure we have at least one field to update
                if len(plUpdateReq) == 0 </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(
                                "at least one field to update must be provided"), nil
                }</span>

                // Call the SDK function
                <span class="cov8" title="1">paymentLink, err := client.PaymentLink.Update(paymentLinkId, plUpdateReq, nil)
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(
                                fmt.Sprintf("updating payment link failed: %s", err.Error())), nil
                }</span>

                <span class="cov8" title="1">return mcpgo.NewToolResultJSON(paymentLink)</span>
        }

        <span class="cov8" title="1">return mcpgo.NewTool(
                "update_payment_link",
                "Update any existing standard or UPI payment link with new details such as reference ID, "+ // nolint:lll
                        "expiry date, or notes.",
                parameters,
                handler,
        )</span>
}

// FetchAllPaymentLinks returns a tool that fetches all payment links
// with optional filtering
func FetchAllPaymentLinks(
        obs *observability.Observability,
        client *rzpsdk.Client,
) mcpgo.Tool <span class="cov8" title="1">{
        parameters := []mcpgo.ToolParameter{
                mcpgo.WithString(
                        "payment_id",
                        mcpgo.Description("Optional: Filter by payment ID associated with payment links"), // nolint:lll
                ),
                mcpgo.WithString(
                        "reference_id",
                        mcpgo.Description("Optional: Filter by reference ID used when creating payment links"), // nolint:lll
                ),
                mcpgo.WithNumber(
                        "upi_link",
                        mcpgo.Description("Optional: Filter only upi links. "+
                                "Value should be 1 if you want only upi links, 0 for only standard links"+
                                "If not provided, all types of links will be returned"),
                ),
        }

        handler := func(
                ctx context.Context,
                r mcpgo.CallToolRequest,
        ) (*mcpgo.ToolResult, error) </span><span class="cov8" title="1">{
                client, err := getClientFromContextOrDefault(ctx, client)
                if err != nil </span><span class="cov0" title="0">{
                        return mcpgo.NewToolResultError(err.Error()), nil
                }</span>

                <span class="cov8" title="1">plListReq := make(map[string]interface{})

                validator := NewValidator(&amp;r).
                        ValidateAndAddOptionalString(plListReq, "payment_id").
                        ValidateAndAddOptionalString(plListReq, "reference_id").
                        ValidateAndAddOptionalInt(plListReq, "upi_link")

                if result, err := validator.HandleErrorsIfAny(); result != nil </span><span class="cov0" title="0">{
                        return result, err
                }</span>

                // Call the API directly using the Request object
                <span class="cov8" title="1">response, err := client.PaymentLink.All(plListReq, nil)
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(
                                fmt.Sprintf("fetching payment links failed: %s", err.Error())), nil
                }</span>

                <span class="cov8" title="1">return mcpgo.NewToolResultJSON(response)</span>
        }

        <span class="cov8" title="1">return mcpgo.NewTool(
                "fetch_all_payment_links",
                "Fetch all payment links with optional filtering by payment ID or reference ID."+ // nolint:lll
                        "You can specify the upi_link parameter to filter by link type.",
                parameters,
                handler,
        )</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package razorpay

import (
        "context"
        "fmt"
        "net/http"
        "net/url"
        "strings"
        "time"

        rzpsdk "github.com/razorpay/razorpay-go"

        "github.com/razorpay/razorpay-mcp-server/pkg/mcpgo"
        "github.com/razorpay/razorpay-mcp-server/pkg/observability"
)

// FetchPayment returns a tool that fetches payment details using payment_id
func FetchPayment(
        obs *observability.Observability,
        client *rzpsdk.Client,
) mcpgo.Tool <span class="cov8" title="1">{
        parameters := []mcpgo.ToolParameter{
                mcpgo.WithString(
                        "payment_id",
                        mcpgo.Description("payment_id is unique identifier "+
                                "of the payment to be retrieved."),
                        mcpgo.Required(),
                ),
        }

        handler := func(
                ctx context.Context,
                r mcpgo.CallToolRequest,
        ) (*mcpgo.ToolResult, error) </span><span class="cov8" title="1">{
                // Get client from context or use default
                client, err := getClientFromContextOrDefault(ctx, client)
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(err.Error()), nil
                }</span>

                <span class="cov8" title="1">params := make(map[string]interface{})

                validator := NewValidator(&amp;r).
                        ValidateAndAddRequiredString(params, "payment_id")

                if result, err := validator.HandleErrorsIfAny(); result != nil </span><span class="cov8" title="1">{
                        return result, err
                }</span>

                <span class="cov8" title="1">paymentId := params["payment_id"].(string)

                payment, err := client.Payment.Fetch(paymentId, nil, nil)
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(
                                fmt.Sprintf("fetching payment failed: %s", err.Error())), nil
                }</span>

                <span class="cov8" title="1">return mcpgo.NewToolResultJSON(payment)</span>
        }

        <span class="cov8" title="1">return mcpgo.NewTool(
                "fetch_payment",
                "Use this tool to retrieve the details of a specific payment "+
                        "using its id. Amount returned is in paisa",
                parameters,
                handler,
        )</span>
}

// FetchPaymentCardDetails returns a tool that fetches card details
// for a payment
func FetchPaymentCardDetails(
        obs *observability.Observability,
        client *rzpsdk.Client,
) mcpgo.Tool <span class="cov8" title="1">{
        parameters := []mcpgo.ToolParameter{
                mcpgo.WithString(
                        "payment_id",
                        mcpgo.Description("Unique identifier of the payment for which "+
                                "you want to retrieve card details. Must start with 'pay_'"),
                        mcpgo.Required(),
                ),
        }

        handler := func(
                ctx context.Context,
                r mcpgo.CallToolRequest,
        ) (*mcpgo.ToolResult, error) </span><span class="cov8" title="1">{
                // Get client from context or use default
                client, err := getClientFromContextOrDefault(ctx, client)
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(err.Error()), nil
                }</span>

                <span class="cov8" title="1">params := make(map[string]interface{})

                validator := NewValidator(&amp;r).
                        ValidateAndAddRequiredString(params, "payment_id")

                if result, err := validator.HandleErrorsIfAny(); result != nil </span><span class="cov8" title="1">{
                        return result, err
                }</span>

                <span class="cov8" title="1">paymentId := params["payment_id"].(string)

                cardDetails, err := client.Payment.FetchCardDetails(
                        paymentId, nil, nil)

                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(
                                fmt.Sprintf("fetching card details failed: %s", err.Error())), nil
                }</span>

                <span class="cov8" title="1">return mcpgo.NewToolResultJSON(cardDetails)</span>
        }

        <span class="cov8" title="1">return mcpgo.NewTool(
                "fetch_payment_card_details",
                "Use this tool to retrieve the details of the card used to make a payment. "+
                        "Only works for payments made using a card.",
                parameters,
                handler,
        )</span>
}

// UpdatePayment returns a tool that updates the notes for a payment
func UpdatePayment(
        obs *observability.Observability,
        client *rzpsdk.Client,
) mcpgo.Tool <span class="cov8" title="1">{
        parameters := []mcpgo.ToolParameter{
                mcpgo.WithString(
                        "payment_id",
                        mcpgo.Description("Unique identifier of the payment to be updated. "+
                                "Must start with 'pay_'"),
                        mcpgo.Required(),
                ),
                mcpgo.WithObject(
                        "notes",
                        mcpgo.Description("Key-value pairs that can be used to store additional "+
                                "information about the payment. Values must be strings or integers."),
                        mcpgo.Required(),
                ),
        }

        handler := func(
                ctx context.Context,
                r mcpgo.CallToolRequest,
        ) (*mcpgo.ToolResult, error) </span><span class="cov8" title="1">{
                // Get client from context or use default
                client, err := getClientFromContextOrDefault(ctx, client)
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(err.Error()), nil
                }</span>

                <span class="cov8" title="1">params := make(map[string]interface{})
                paymentUpdateReq := make(map[string]interface{})

                validator := NewValidator(&amp;r).
                        ValidateAndAddRequiredString(params, "payment_id").
                        ValidateAndAddRequiredMap(paymentUpdateReq, "notes")

                if result, err := validator.HandleErrorsIfAny(); result != nil </span><span class="cov8" title="1">{
                        return result, err
                }</span>

                <span class="cov8" title="1">paymentId := params["payment_id"].(string)

                // Update the payment
                updatedPayment, err := client.Payment.Edit(paymentId, paymentUpdateReq, nil)
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(
                                fmt.Sprintf("updating payment failed: %s", err.Error())), nil
                }</span>

                <span class="cov8" title="1">return mcpgo.NewToolResultJSON(updatedPayment)</span>
        }

        <span class="cov8" title="1">return mcpgo.NewTool(
                "update_payment",
                "Use this tool to update the notes field of a payment. Notes are "+
                        "key-value pairs that can be used to store additional information.", //nolint:lll
                parameters,
                handler,
        )</span>
}

// CapturePayment returns a tool that captures an authorized payment
func CapturePayment(
        obs *observability.Observability,
        client *rzpsdk.Client,
) mcpgo.Tool <span class="cov8" title="1">{
        parameters := []mcpgo.ToolParameter{
                mcpgo.WithString(
                        "payment_id",
                        mcpgo.Description("Unique identifier of the payment to be captured. Should start with 'pay_'"), //nolint:lll
                        mcpgo.Required(),
                ),
                mcpgo.WithNumber(
                        "amount",
                        mcpgo.Description("The amount to be captured (in paisa). "+
                                "Should be equal to the authorized amount"),
                        mcpgo.Required(),
                ),
                mcpgo.WithString(
                        "currency",
                        mcpgo.Description("ISO code of the currency in which the payment "+
                                "was made (e.g., INR)"),
                        mcpgo.Required(),
                ),
        }

        handler := func(
                ctx context.Context,
                r mcpgo.CallToolRequest,
        ) (*mcpgo.ToolResult, error) </span><span class="cov8" title="1">{
                // Get client from context or use default
                client, err := getClientFromContextOrDefault(ctx, client)
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(err.Error()), nil
                }</span>

                <span class="cov8" title="1">params := make(map[string]interface{})
                paymentCaptureReq := make(map[string]interface{})

                validator := NewValidator(&amp;r).
                        ValidateAndAddRequiredString(params, "payment_id").
                        ValidateAndAddRequiredInt(params, "amount").
                        ValidateAndAddRequiredString(paymentCaptureReq, "currency")

                if result, err := validator.HandleErrorsIfAny(); result != nil </span><span class="cov8" title="1">{
                        return result, err
                }</span>

                <span class="cov8" title="1">paymentId := params["payment_id"].(string)
                amount := int(params["amount"].(int64))

                // Capture the payment
                payment, err := client.Payment.Capture(
                        paymentId,
                        amount,
                        paymentCaptureReq,
                        nil,
                )
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(
                                fmt.Sprintf("capturing payment failed: %s", err.Error())), nil
                }</span>

                <span class="cov8" title="1">return mcpgo.NewToolResultJSON(payment)</span>
        }

        <span class="cov8" title="1">return mcpgo.NewTool(
                "capture_payment",
                "Use this tool to capture a previously authorized payment. Only payments with 'authorized' status can be captured", //nolint:lll
                parameters,
                handler,
        )</span>
}

// FetchAllPayments returns a tool to fetch multiple payments with filtering and pagination
//
//nolint:lll
func FetchAllPayments(
        obs *observability.Observability,
        client *rzpsdk.Client,
) mcpgo.Tool <span class="cov8" title="1">{
        parameters := []mcpgo.ToolParameter{
                // Pagination parameters
                mcpgo.WithNumber(
                        "count",
                        mcpgo.Description("Number of payments to fetch "+
                                "(default: 10, max: 100)"),
                        mcpgo.Min(1),
                        mcpgo.Max(100),
                ),
                mcpgo.WithNumber(
                        "skip",
                        mcpgo.Description("Number of payments to skip (default: 0)"),
                        mcpgo.Min(0),
                ),
                // Time range filters
                mcpgo.WithNumber(
                        "from",
                        mcpgo.Description("Unix timestamp (in seconds) from when "+
                                "payments are to be fetched"),
                        mcpgo.Min(0),
                ),
                mcpgo.WithNumber(
                        "to",
                        mcpgo.Description("Unix timestamp (in seconds) up till when "+
                                "payments are to be fetched"),
                        mcpgo.Min(0),
                ),
        }

        handler := func(
                ctx context.Context,
                r mcpgo.CallToolRequest,
        ) (*mcpgo.ToolResult, error) </span><span class="cov8" title="1">{
                // Get client from context or use default
                client, err := getClientFromContextOrDefault(ctx, client)
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(err.Error()), nil
                }</span>

                // Create query parameters map
                <span class="cov8" title="1">paymentListOptions := make(map[string]interface{})

                validator := NewValidator(&amp;r).
                        ValidateAndAddPagination(paymentListOptions).
                        ValidateAndAddOptionalInt(paymentListOptions, "from").
                        ValidateAndAddOptionalInt(paymentListOptions, "to")

                if result, err := validator.HandleErrorsIfAny(); result != nil </span><span class="cov8" title="1">{
                        return result, err
                }</span>

                // Fetch all payments using Razorpay SDK
                <span class="cov8" title="1">payments, err := client.Payment.All(paymentListOptions, nil)
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(
                                fmt.Sprintf("fetching payments failed: %s", err.Error())), nil
                }</span>

                <span class="cov8" title="1">return mcpgo.NewToolResultJSON(payments)</span>
        }

        <span class="cov8" title="1">return mcpgo.NewTool(
                "fetch_all_payments",
                "Fetch all payments with optional filtering and pagination",
                parameters,
                handler,
        )</span>
}

// extractPaymentID extracts the payment ID from the payment response
func extractPaymentID(payment map[string]interface{}) string <span class="cov8" title="1">{
        if id, exists := payment["razorpay_payment_id"]; exists &amp;&amp; id != nil </span><span class="cov8" title="1">{
                return id.(string)
        }</span>
        <span class="cov8" title="1">return ""</span>
}

// extractNextActions extracts all available actions from the payment response
func extractNextActions(
        payment map[string]interface{},
) []map[string]interface{} <span class="cov8" title="1">{
        var actions []map[string]interface{}
        if nextArray, exists := payment["next"]; exists &amp;&amp; nextArray != nil </span><span class="cov8" title="1">{
                if nextSlice, ok := nextArray.([]interface{}); ok </span><span class="cov8" title="1">{
                        for _, item := range nextSlice </span><span class="cov8" title="1">{
                                if nextItem, ok := item.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                        actions = append(actions, nextItem)
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return actions</span>
}

// OTPResponse represents the response from OTP generation API

// sendOtp sends an OTP to the customer and returns the response
func sendOtp(otpUrl string) error <span class="cov8" title="1">{
        if otpUrl == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("OTP URL is empty")
        }</span>
        // Validate URL is safe and from Razorpay domain for security
        <span class="cov8" title="1">parsedURL, err := url.Parse(otpUrl)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid OTP URL: %s", err.Error())
        }</span>

        <span class="cov8" title="1">if parsedURL.Scheme != "https" </span><span class="cov8" title="1">{
                return fmt.Errorf("OTP URL must use HTTPS")
        }</span>

        <span class="cov8" title="1">if !strings.Contains(parsedURL.Host, "razorpay.com") </span><span class="cov8" title="1">{
                return fmt.Errorf("OTP URL must be from Razorpay domain")
        }</span>

        // Create a secure HTTP client with timeout
        <span class="cov8" title="1">client := &amp;http.Client{
                Timeout: 10 * time.Second,
        }

        req, err := http.NewRequest("POST", otpUrl, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create OTP request: %s", err.Error())
        }</span>
        <span class="cov8" title="1">req.Header.Set("Content-Type", "application/json")

        resp, err := client.Do(req)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("OTP generation failed: %s", err.Error())
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        // Validate HTTP response status
        if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov8" title="1">{
                return fmt.Errorf("OTP generation failed with HTTP status: %d",
                        resp.StatusCode)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// buildInitiatePaymentResponse constructs the response for initiate payment
func buildInitiatePaymentResponse(
        payment map[string]interface{},
        paymentID string,
        actions []map[string]interface{},
) (map[string]interface{}, string) <span class="cov8" title="1">{
        response := map[string]interface{}{
                "razorpay_payment_id": paymentID,
                "payment_details":     payment,
                "status":              "payment_initiated",
                "message": "Payment initiated successfully using " +
                        "S2S JSON v1 flow",
        }
        otpUrl := ""

        if len(actions) &gt; 0 </span><span class="cov8" title="1">{
                response["available_actions"] = actions

                // Add guidance based on available actions
                var actionTypes []string
                hasOTP := false
                hasRedirect := false
                hasUPICollect := false
                hasUPIIntent := false

                for _, action := range actions </span><span class="cov8" title="1">{
                        if actionType, exists := action["action"]; exists </span><span class="cov8" title="1">{
                                actionStr := actionType.(string)
                                actionTypes = append(actionTypes, actionStr)
                                if actionStr == "otp_generate" </span><span class="cov8" title="1">{
                                        hasOTP = true
                                        otpUrl = action["url"].(string)
                                }</span>

                                <span class="cov8" title="1">if actionStr == "redirect" </span><span class="cov8" title="1">{
                                        hasRedirect = true
                                }</span>

                                <span class="cov8" title="1">if actionStr == "upi_collect" </span><span class="cov8" title="1">{
                                        hasUPICollect = true
                                }</span>

                                <span class="cov8" title="1">if actionStr == "upi_intent" </span><span class="cov8" title="1">{
                                        hasUPIIntent = true
                                }</span>
                        }
                }

                <span class="cov8" title="1">switch </span>{
                case hasOTP:<span class="cov8" title="1">
                        response["message"] = "Payment initiated. OTP authentication is " +
                                "available. " +
                                "Use the 'submit_otp' tool to submit OTP received by the customer " +
                                "for authentication."
                        addNextStepInstructions(response, paymentID)</span>
                case hasRedirect:<span class="cov8" title="1">
                        response["message"] = "Payment initiated. Redirect authentication is " +
                                "available. Use the redirect URL provided in available_actions."</span>
                case hasUPICollect:<span class="cov8" title="1">
                        response["message"] = fmt.Sprintf(
                                "Payment initiated. Available actions: %v", actionTypes)</span>
                case hasUPIIntent:<span class="cov8" title="1">
                        response["message"] = fmt.Sprintf(
                                "Payment initiated. Available actions: %v", actionTypes)</span>
                default:<span class="cov8" title="1">
                        response["message"] = fmt.Sprintf(
                                "Payment initiated. Available actions: %v", actionTypes)</span>
                }
        } else<span class="cov8" title="1"> {
                addFallbackNextStepInstructions(response, paymentID)
        }</span>

        <span class="cov8" title="1">return response, otpUrl</span>
}

// addNextStepInstructions adds next step guidance to the response
func addNextStepInstructions(
        response map[string]interface{},
        paymentID string,
) <span class="cov8" title="1">{
        if paymentID != "" </span><span class="cov8" title="1">{
                response["next_step"] = "Use 'resend_otp' to regenerate OTP or " +
                        "'submit_otp' to proceed to enter OTP."
                response["next_tool"] = "resend_otp"
                response["next_tool_params"] = map[string]interface{}{
                        "payment_id": paymentID,
                }
        }</span>
}

// addFallbackNextStepInstructions adds fallback next step guidance
func addFallbackNextStepInstructions(
        response map[string]interface{},
        paymentID string,
) <span class="cov8" title="1">{
        if paymentID != "" </span><span class="cov8" title="1">{
                response["next_step"] = "Use 'resend_otp' to regenerate OTP or " +
                        "'submit_otp' to proceed to enter OTP if " +
                        "OTP authentication is required."
                response["next_tool"] = "resend_otp"
                response["next_tool_params"] = map[string]interface{}{
                        "payment_id": paymentID,
                }
        }</span>
}

// addContactAndEmailToPaymentData adds contact and email to payment data
func addContactAndEmailToPaymentData(
        paymentData map[string]interface{},
        params map[string]interface{},
) <span class="cov8" title="1">{
        // Add contact if provided
        if contact, exists := params["contact"]; exists &amp;&amp; contact != "" </span><span class="cov8" title="1">{
                paymentData["contact"] = contact
        }</span>

        // Add email if provided, otherwise generate from contact
        <span class="cov8" title="1">if email, exists := params["email"]; exists &amp;&amp; email != "" </span><span class="cov8" title="1">{
                paymentData["email"] = email
        }</span> else<span class="cov8" title="1"> if contact, exists := paymentData["contact"]; exists &amp;&amp; contact != "" </span><span class="cov8" title="1">{
                paymentData["email"] = contact.(string) + "@mcp.razorpay.com"
        }</span>
}

// addAdditionalPaymentParameters adds additional parameters for UPI collect
// and other flows
func addAdditionalPaymentParameters(
        paymentData map[string]interface{},
        params map[string]interface{},
) <span class="cov8" title="1">{
        // Note: customer_id is now handled explicitly in buildPaymentData

        // Add method if provided
        if method, exists := params["method"]; exists &amp;&amp; method != "" </span><span class="cov8" title="1">{
                paymentData["method"] = method
        }</span>

        // Add save if provided
        <span class="cov8" title="1">if save, exists := params["save"]; exists </span><span class="cov8" title="1">{
                paymentData["save"] = save
        }</span>

        // Add recurring if provided
        <span class="cov8" title="1">if recurring, exists := params["recurring"]; exists </span><span class="cov8" title="1">{
                paymentData["recurring"] = recurring
        }</span>

        // Add UPI parameters if provided
        <span class="cov8" title="1">if upiParams, exists := params["upi"]; exists &amp;&amp; upiParams != nil </span><span class="cov8" title="1">{
                if upiMap, ok := upiParams.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        paymentData["upi"] = upiMap
                }</span>
        }
}

// processUPIParameters handles VPA and UPI intent parameter processing
func processUPIParameters(params map[string]interface{}) <span class="cov8" title="1">{
        vpa, hasVPA := params["vpa"]
        upiIntent, hasUPIIntent := params["upi_intent"]

        // Handle VPA parameter (UPI collect flow)
        if hasVPA &amp;&amp; vpa != "" </span><span class="cov8" title="1">{
                // Set method to UPI
                params["method"] = "upi"
                // Set UPI parameters for collect flow
                params["upi"] = map[string]interface{}{
                        "flow":        "collect",
                        "expiry_time": "6",
                        "vpa":         vpa,
                }
        }</span>

        // Handle UPI intent parameter (UPI intent flow)
        <span class="cov8" title="1">if hasUPIIntent &amp;&amp; upiIntent == true </span><span class="cov8" title="1">{
                // Set method to UPI
                params["method"] = "upi"
                // Set UPI parameters for intent flow
                params["upi"] = map[string]interface{}{
                        "flow": "intent",
                }
        }</span>
}

// createOrGetCustomer creates or gets a customer if contact is provided
func createOrGetCustomer(
        client *rzpsdk.Client,
        params map[string]interface{},
) (map[string]interface{}, error) <span class="cov8" title="1">{
        contactValue, exists := params["contact"]
        if !exists || contactValue == "" </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">contact := contactValue.(string)
        customerData := map[string]interface{}{
                "contact":       contact,
                "fail_existing": "0", // Get existing customer if exists
        }

        // Create/get customer using Razorpay SDK
        customer, err := client.Customer.Create(customerData, nil)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf(
                        "failed to create/fetch customer with contact %s: %v",
                        contact,
                        err,
                )
        }</span>
        <span class="cov8" title="1">return customer, nil</span>
}

// buildPaymentData constructs the payment data for the API call
func buildPaymentData(
        params map[string]interface{},
        currency string,
        customerId string,
) *map[string]interface{} <span class="cov8" title="1">{
        paymentData := map[string]interface{}{
                "amount":   params["amount"],
                "currency": currency,
                "order_id": params["order_id"],
        }
        if customerId != "" </span><span class="cov8" title="1">{
                paymentData["customer_id"] = customerId
        }</span>

        // Add token if provided (required for saved payment methods,
        // optional for UPI collect)
        <span class="cov8" title="1">if token, exists := params["token"]; exists &amp;&amp; token != "" </span><span class="cov8" title="1">{
                paymentData["token"] = token
        }</span>

        // Add contact and email parameters
        <span class="cov8" title="1">addContactAndEmailToPaymentData(paymentData, params)

        // Add additional parameters for UPI collect and other flows
        addAdditionalPaymentParameters(paymentData, params)

        // Add force_terminal_id if provided (for single block multiple debit orders)
        if terminalID, exists := params["force_terminal_id"]; exists &amp;&amp;
                terminalID != "" </span><span class="cov8" title="1">{
                paymentData["force_terminal_id"] = terminalID
        }</span>

        <span class="cov8" title="1">return &amp;paymentData</span>
}

// processPaymentResult processes the payment creation result
func processPaymentResult(
        payment map[string]interface{},
) (map[string]interface{}, error) <span class="cov8" title="1">{
        // Extract payment ID and next actions from the response
        paymentID := extractPaymentID(payment)
        actions := extractNextActions(payment)

        // Build structured response using the helper function
        response, otpUrl := buildInitiatePaymentResponse(payment, paymentID, actions)

        // Only send OTP if there's an OTP URL
        if otpUrl != "" </span><span class="cov8" title="1">{
                err := sendOtp(otpUrl)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("OTP generation failed: %s", err.Error())
                }</span>
        }

        <span class="cov8" title="1">return response, nil</span>
}

// InitiatePayment returns a tool that initiates a payment using order_id
// and token
// This implements the S2S JSON v1 flow for creating payments
func InitiatePayment(
        obs *observability.Observability,
        client *rzpsdk.Client,
) mcpgo.Tool <span class="cov8" title="1">{
        parameters := []mcpgo.ToolParameter{
                mcpgo.WithNumber(
                        "amount",
                        mcpgo.Description("Payment amount in the smallest currency sub-unit "+
                                "(e.g., for 100, use 10000)"),
                        mcpgo.Required(),
                        mcpgo.Min(100),
                ),
                mcpgo.WithString(
                        "currency",
                        mcpgo.Description("Currency code for the payment. Default is 'INR'"),
                ),
                mcpgo.WithString(
                        "token",
                        mcpgo.Description("Token ID of the saved payment method. "+
                                "Must start with 'token_'"),
                ),
                mcpgo.WithString(
                        "order_id",
                        mcpgo.Description("Order ID for which the payment is being initiated. "+
                                "Must start with 'order_'"),
                        mcpgo.Required(),
                ),
                mcpgo.WithString(
                        "email",
                        mcpgo.Description("Customer's email address (optional)"),
                ),
                mcpgo.WithString(
                        "contact",
                        mcpgo.Description("Customer's phone number"),
                ),
                mcpgo.WithString(
                        "customer_id",
                        mcpgo.Description("Customer ID for the payment. "+
                                "Must start with 'cust_'"),
                ),
                mcpgo.WithBoolean(
                        "save",
                        mcpgo.Description("Whether to save the payment method for future use"),
                ),
                mcpgo.WithString(
                        "vpa",
                        mcpgo.Description("Virtual Payment Address (VPA) for UPI payment. "+
                                "When provided, automatically sets method='upi' and UPI parameters "+
                                "with flow='collect' and expiry_time='6' (e.g., '9876543210@ptsbi')"),
                ),
                mcpgo.WithBoolean(
                        "upi_intent",
                        mcpgo.Description("Enable UPI intent flow. "+
                                "When set to true, automatically sets method='upi' and UPI parameters "+
                                "with flow='intent'. The API will return a UPI URL in the response."),
                ),
                mcpgo.WithBoolean(
                        "recurring",
                        mcpgo.Description("Set this to true for recurring payments like "+
                                "single block multiple debit."),
                ),
                mcpgo.WithString(
                        "force_terminal_id",
                        mcpgo.Description("Terminal ID to be passed in case of single block "+
                                "multiple debit order."),
                ),
        }

        handler := func(
                ctx context.Context,
                r mcpgo.CallToolRequest,
        ) (*mcpgo.ToolResult, error) </span><span class="cov8" title="1">{
                // Get client from context or use default
                client, err := getClientFromContextOrDefault(ctx, client)
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(err.Error()), nil
                }</span>

                <span class="cov8" title="1">params := make(map[string]interface{})

                validator := NewValidator(&amp;r).
                        ValidateAndAddRequiredInt(params, "amount").
                        ValidateAndAddOptionalString(params, "currency").
                        ValidateAndAddOptionalString(params, "token").
                        ValidateAndAddRequiredString(params, "order_id").
                        ValidateAndAddOptionalString(params, "email").
                        ValidateAndAddOptionalString(params, "contact").
                        ValidateAndAddOptionalString(params, "customer_id").
                        ValidateAndAddOptionalBool(params, "save").
                        ValidateAndAddOptionalString(params, "vpa").
                        ValidateAndAddOptionalBool(params, "upi_intent").
                        ValidateAndAddOptionalBool(params, "recurring").
                        ValidateAndAddOptionalString(params, "force_terminal_id")

                if result, err := validator.HandleErrorsIfAny(); result != nil </span><span class="cov8" title="1">{
                        return result, err
                }</span>

                // Set default currency
                <span class="cov8" title="1">currency := "INR"
                if c, exists := params["currency"]; exists &amp;&amp; c != "" </span><span class="cov8" title="1">{
                        currency = c.(string)
                }</span>

                // Process UPI parameters (VPA for collect flow, upi_intent for intent flow)
                <span class="cov8" title="1">processUPIParameters(params)

                // Handle customer ID
                var customerID string
                if custID, exists := params["customer_id"]; exists &amp;&amp; custID != "" </span><span class="cov8" title="1">{
                        customerID = custID.(string)
                }</span> else<span class="cov8" title="1"> {
                        // Create or get customer if contact is provided
                        customer, err := createOrGetCustomer(client, params)
                        if err != nil </span><span class="cov0" title="0">{
                                return mcpgo.NewToolResultError(err.Error()), nil
                        }</span>
                        <span class="cov8" title="1">if customer != nil </span><span class="cov8" title="1">{
                                if id, ok := customer["id"].(string); ok </span><span class="cov8" title="1">{
                                        customerID = id
                                }</span>
                        }
                }

                // Build payment data
                <span class="cov8" title="1">paymentDataPtr := buildPaymentData(params, currency, customerID)
                paymentData := *paymentDataPtr

                // Create payment using Razorpay SDK's CreatePaymentJson method
                // This follows the S2S JSON v1 flow:
                // https://api.razorpay.com/v1/payments/create/json
                payment, err := client.Payment.CreatePaymentJson(paymentData, nil)
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(
                                fmt.Sprintf("initiating payment failed: %s", err.Error())), nil
                }</span>

                // Process payment result
                <span class="cov8" title="1">response, err := processPaymentResult(payment)
                if err != nil </span><span class="cov0" title="0">{
                        return mcpgo.NewToolResultError(err.Error()), nil
                }</span>

                <span class="cov8" title="1">return mcpgo.NewToolResultJSON(response)</span>
        }

        <span class="cov8" title="1">return mcpgo.NewTool(
                "initiate_payment",
                "Initiate a payment using the S2S JSON v1 flow. "+
                        "Required parameters: amount and order_id. "+
                        "For saved payment methods, provide token. "+
                        "For UPI collect flow, provide 'vpa' parameter "+
                        "which automatically sets UPI with flow='collect' and expiry_time='6'. "+
                        "For UPI intent flow, set 'upi_intent=true' parameter "+
                        "which automatically sets UPI with flow='intent' and API returns UPI URL. "+
                        "Supports additional parameters like customer_id, email, "+
                        "contact, save, and recurring. "+
                        "Returns payment details including next action steps if required.",
                parameters,
                handler,
        )</span>
}

// ResendOtp returns a tool that sends OTP for payment authentication
func ResendOtp(
        obs *observability.Observability,
        client *rzpsdk.Client,
) mcpgo.Tool <span class="cov8" title="1">{
        parameters := []mcpgo.ToolParameter{
                mcpgo.WithString(
                        "payment_id",
                        mcpgo.Description("Unique identifier of the payment for which "+
                                "OTP needs to be generated. Must start with 'pay_'"),
                        mcpgo.Required(),
                ),
        }

        handler := func(
                ctx context.Context,
                r mcpgo.CallToolRequest,
        ) (*mcpgo.ToolResult, error) </span><span class="cov8" title="1">{

                // Get client from context or use default
                client, err := getClientFromContextOrDefault(ctx, client)
                if err != nil </span><span class="cov0" title="0">{
                        return mcpgo.NewToolResultError(err.Error()), nil
                }</span>

                <span class="cov8" title="1">params := make(map[string]interface{})

                validator := NewValidator(&amp;r).
                        ValidateAndAddRequiredString(params, "payment_id")

                if result, err := validator.HandleErrorsIfAny(); result != nil </span><span class="cov8" title="1">{
                        return result, err
                }</span>

                <span class="cov8" title="1">paymentID := params["payment_id"].(string)

                // Resend OTP using Razorpay SDK
                otpResponse, err := client.Payment.OtpResend(paymentID, nil, nil)
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(
                                fmt.Sprintf("OTP resend failed: %s", err.Error())), nil
                }</span>

                // Extract OTP submit URL from response
                <span class="cov8" title="1">otpSubmitURL := extractOtpSubmitURL(otpResponse)

                // Prepare response
                response := map[string]interface{}{
                        "payment_id": paymentID,
                        "status":     "success",
                        "message": "OTP sent successfully. Please enter the OTP received on your " +
                                "mobile number to complete the payment.",
                        "response_data": otpResponse,
                }

                // Add next step instructions if OTP submit URL is available
                if otpSubmitURL != "" </span><span class="cov8" title="1">{
                        response["otp_submit_url"] = otpSubmitURL
                        response["next_step"] = "Use 'submit_otp' tool with the OTP code received " +
                                "from user to complete payment authentication."
                        response["next_tool"] = "submit_otp"
                        response["next_tool_params"] = map[string]interface{}{
                                "payment_id": paymentID,
                                "otp_string": "{OTP_CODE_FROM_USER}",
                        }
                }</span> else<span class="cov8" title="1"> {
                        response["next_step"] = "Use 'submit_otp' tool with the OTP code received " +
                                "from user to complete payment authentication."
                        response["next_tool"] = "submit_otp"
                        response["next_tool_params"] = map[string]interface{}{
                                "payment_id": paymentID,
                                "otp_string": "{OTP_CODE_FROM_USER}",
                        }
                }</span>

                <span class="cov8" title="1">result, err := mcpgo.NewToolResultJSON(response)
                if err != nil </span><span class="cov0" title="0">{
                        return mcpgo.NewToolResultError(
                                fmt.Sprintf("JSON marshal error: %v", err)), nil
                }</span>
                <span class="cov8" title="1">return result, nil</span>
        }

        <span class="cov8" title="1">return mcpgo.NewTool(
                "resend_otp",
                "Resend OTP to the customer's registered mobile number if the previous "+
                        "OTP was not received or has expired.",
                parameters,
                handler,
        )</span>
}

// SubmitOtp returns a tool that submits OTP for payment verification
func SubmitOtp(
        obs *observability.Observability,
        client *rzpsdk.Client,
) mcpgo.Tool <span class="cov8" title="1">{
        parameters := []mcpgo.ToolParameter{
                mcpgo.WithString(
                        "otp_string",
                        mcpgo.Description("OTP string received from the user"),
                        mcpgo.Required(),
                ),
                mcpgo.WithString(
                        "payment_id",
                        mcpgo.Description("Unique identifier of the payment for which "+
                                "OTP needs to be submitted. Must start with 'pay_'"),
                        mcpgo.Required(),
                ),
        }

        handler := func(
                ctx context.Context,
                r mcpgo.CallToolRequest,
        ) (*mcpgo.ToolResult, error) </span><span class="cov8" title="1">{
                // Get client from context or use default
                client, err := getClientFromContextOrDefault(ctx, client)
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(err.Error()), nil
                }</span>

                <span class="cov8" title="1">params := make(map[string]interface{})

                validator := NewValidator(&amp;r).
                        ValidateAndAddRequiredString(params, "otp_string").
                        ValidateAndAddRequiredString(params, "payment_id")

                if result, err := validator.HandleErrorsIfAny(); result != nil </span><span class="cov8" title="1">{
                        return result, err
                }</span>

                <span class="cov8" title="1">paymentID := params["payment_id"].(string)
                data := map[string]interface{}{
                        "otp": params["otp_string"].(string),
                }
                otpResponse, err := client.Payment.OtpSubmit(paymentID, data, nil)

                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(
                                fmt.Sprintf("OTP verification failed: %s", err.Error())), nil
                }</span>

                // Prepare response
                <span class="cov8" title="1">response := map[string]interface{}{
                        "payment_id":    paymentID,
                        "status":        "success",
                        "message":       "OTP verified successfully.",
                        "response_data": otpResponse,
                }
                result, err := mcpgo.NewToolResultJSON(response)
                if err != nil </span><span class="cov0" title="0">{
                        return mcpgo.NewToolResultError(
                                fmt.Sprintf("JSON marshal error: %v", err)), nil
                }</span>
                <span class="cov8" title="1">return result, nil</span>
        }

        <span class="cov8" title="1">return mcpgo.NewTool(
                "submit_otp",
                "Verify and submit the OTP received by the customer to complete "+
                        "the payment authentication process.",
                parameters,
                handler,
        )</span>
}

// extractOtpSubmitURL extracts the OTP submit URL from the payment response
func extractOtpSubmitURL(responseData interface{}) string <span class="cov8" title="1">{
        jsonData, ok := responseData.(map[string]interface{})
        if !ok </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">nextArray, exists := jsonData["next"]
        if !exists || nextArray == nil </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">nextSlice, ok := nextArray.([]interface{})
        if !ok </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">for _, item := range nextSlice </span><span class="cov8" title="1">{
                nextItem, ok := item.(map[string]interface{})
                if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">action, exists := nextItem["action"]
                if !exists || action != "otp_submit" </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">submitURL, exists := nextItem["url"]
                if exists &amp;&amp; submitURL != nil </span><span class="cov8" title="1">{
                        if urlStr, ok := submitURL.(string); ok </span><span class="cov8" title="1">{
                                return urlStr
                        }</span>
                }
        }

        <span class="cov8" title="1">return ""</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package razorpay

import (
        "context"
        "fmt"

        rzpsdk "github.com/razorpay/razorpay-go"

        "github.com/razorpay/razorpay-mcp-server/pkg/mcpgo"
        "github.com/razorpay/razorpay-mcp-server/pkg/observability"
)

// FetchPayoutByID returns a tool that fetches a payout by its ID
func FetchPayout(
        obs *observability.Observability,
        client *rzpsdk.Client,
) mcpgo.Tool <span class="cov8" title="1">{
        parameters := []mcpgo.ToolParameter{
                mcpgo.WithString(
                        "payout_id",
                        mcpgo.Description(
                                "The unique identifier of the payout. For example, 'pout_00000000000001'",
                        ),
                        mcpgo.Required(),
                ),
        }

        handler := func(
                ctx context.Context,
                r mcpgo.CallToolRequest,
        ) (*mcpgo.ToolResult, error) </span><span class="cov8" title="1">{
                client, err := getClientFromContextOrDefault(ctx, client)
                if err != nil </span><span class="cov0" title="0">{
                        return mcpgo.NewToolResultError(err.Error()), nil
                }</span>

                <span class="cov8" title="1">FetchPayoutOptions := make(map[string]interface{})

                validator := NewValidator(&amp;r).
                        ValidateAndAddRequiredString(FetchPayoutOptions, "payout_id")

                if result, err := validator.HandleErrorsIfAny(); result != nil </span><span class="cov8" title="1">{
                        return result, err
                }</span>

                <span class="cov8" title="1">payout, err := client.Payout.Fetch(
                        FetchPayoutOptions["payout_id"].(string),
                        nil,
                        nil,
                )
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(
                                fmt.Sprintf("fetching payout failed: %s", err.Error())), nil
                }</span>

                <span class="cov8" title="1">return mcpgo.NewToolResultJSON(payout)</span>
        }

        <span class="cov8" title="1">return mcpgo.NewTool(
                "fetch_payout_with_id",
                "Fetch a payout's details using its ID",
                parameters,
                handler,
        )</span>
}

// FetchAllPayouts returns a tool that fetches all payouts
func FetchAllPayouts(
        obs *observability.Observability,
        client *rzpsdk.Client,
) mcpgo.Tool <span class="cov8" title="1">{
        parameters := []mcpgo.ToolParameter{
                mcpgo.WithString(
                        "account_number",
                        mcpgo.Description("The account from which the payouts were done."+
                                "For example, 7878780080316316"),
                        mcpgo.Required(),
                ),
                mcpgo.WithNumber(
                        "count",
                        mcpgo.Description("Number of payouts to be fetched. Default value is 10."+
                                "Maximum value is 100. This can be used for pagination,"+
                                "in combination with the skip parameter"),
                        mcpgo.Min(1),
                ),
                mcpgo.WithNumber(
                        "skip",
                        mcpgo.Description("Numbers of payouts to be skipped. Default value is 0."+
                                "This can be used for pagination, in combination with count"),
                        mcpgo.Min(0),
                ),
        }

        handler := func(
                ctx context.Context,
                r mcpgo.CallToolRequest,
        ) (*mcpgo.ToolResult, error) </span><span class="cov8" title="1">{
                client, err := getClientFromContextOrDefault(ctx, client)
                if err != nil </span><span class="cov0" title="0">{
                        return mcpgo.NewToolResultError(err.Error()), nil
                }</span>

                <span class="cov8" title="1">FetchAllPayoutsOptions := make(map[string]interface{})

                validator := NewValidator(&amp;r).
                        ValidateAndAddRequiredString(FetchAllPayoutsOptions, "account_number").
                        ValidateAndAddPagination(FetchAllPayoutsOptions)

                if result, err := validator.HandleErrorsIfAny(); result != nil </span><span class="cov8" title="1">{
                        return result, err
                }</span>

                <span class="cov8" title="1">payout, err := client.Payout.All(FetchAllPayoutsOptions, nil)
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(
                                fmt.Sprintf("fetching payouts failed: %s", err.Error())), nil
                }</span>

                <span class="cov8" title="1">return mcpgo.NewToolResultJSON(payout)</span>
        }

        <span class="cov8" title="1">return mcpgo.NewTool(
                "fetch_all_payouts",
                "Fetch all payouts for a bank account number",
                parameters,
                handler,
        )</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package razorpay

import (
        "context"
        "fmt"

        rzpsdk "github.com/razorpay/razorpay-go"

        "github.com/razorpay/razorpay-mcp-server/pkg/mcpgo"
        "github.com/razorpay/razorpay-mcp-server/pkg/observability"
)

// CreateQRCode returns a tool that creates QR codes in Razorpay
func CreateQRCode(
        obs *observability.Observability,
        client *rzpsdk.Client,
) mcpgo.Tool <span class="cov8" title="1">{
        parameters := []mcpgo.ToolParameter{
                mcpgo.WithString(
                        "type",
                        mcpgo.Description(
                                "The type of the QR Code. Currently only supports 'upi_qr'",
                        ),
                        mcpgo.Required(),
                        mcpgo.Pattern("^upi_qr$"),
                ),
                mcpgo.WithString(
                        "name",
                        mcpgo.Description(
                                "Label to identify the QR Code (e.g., 'Store Front Display')",
                        ),
                ),
                mcpgo.WithString(
                        "usage",
                        mcpgo.Description(
                                "Whether QR should accept single or multiple payments. "+
                                        "Possible values: 'single_use', 'multiple_use'",
                        ),
                        mcpgo.Required(),
                        mcpgo.Enum("single_use", "multiple_use"),
                ),
                mcpgo.WithBoolean(
                        "fixed_amount",
                        mcpgo.Description(
                                "Whether QR should accept only specific amount (true) or any "+
                                        "amount (false)",
                        ),
                        mcpgo.DefaultValue(false),
                ),
                mcpgo.WithNumber(
                        "payment_amount",
                        mcpgo.Description(
                                "The specific amount allowed for transaction in smallest "+
                                        "currency unit",
                        ),
                        mcpgo.Min(1),
                ),
                mcpgo.WithString(
                        "description",
                        mcpgo.Description("A brief description about the QR Code"),
                ),
                mcpgo.WithString(
                        "customer_id",
                        mcpgo.Description(
                                "The unique identifier of the customer to link with the QR Code",
                        ),
                ),
                mcpgo.WithNumber(
                        "close_by",
                        mcpgo.Description(
                                "Unix timestamp at which QR Code should be automatically "+
                                        "closed (min 2 mins after current time)",
                        ),
                ),
                mcpgo.WithObject(
                        "notes",
                        mcpgo.Description(
                                "Key-value pairs for additional information "+
                                        "(max 15 pairs, 256 chars each)",
                        ),
                        mcpgo.MaxProperties(15),
                ),
        }

        handler := func(
                ctx context.Context,
                r mcpgo.CallToolRequest,
        ) (*mcpgo.ToolResult, error) </span><span class="cov8" title="1">{
                client, err := getClientFromContextOrDefault(ctx, client)
                if err != nil </span><span class="cov0" title="0">{
                        return mcpgo.NewToolResultError(err.Error()), nil
                }</span>

                <span class="cov8" title="1">qrData := make(map[string]interface{})

                validator := NewValidator(&amp;r).
                        ValidateAndAddRequiredString(qrData, "type").
                        ValidateAndAddRequiredString(qrData, "usage").
                        ValidateAndAddOptionalString(qrData, "name").
                        ValidateAndAddOptionalBool(qrData, "fixed_amount").
                        ValidateAndAddOptionalFloat(qrData, "payment_amount").
                        ValidateAndAddOptionalString(qrData, "description").
                        ValidateAndAddOptionalString(qrData, "customer_id").
                        ValidateAndAddOptionalFloat(qrData, "close_by").
                        ValidateAndAddOptionalMap(qrData, "notes")

                if result, err := validator.HandleErrorsIfAny(); result != nil </span><span class="cov8" title="1">{
                        return result, err
                }</span>

                // Check if fixed_amount is true, then payment_amount is required
                <span class="cov8" title="1">if fixedAmount, exists := qrData["fixed_amount"]; exists &amp;&amp;
                        fixedAmount.(bool) </span><span class="cov8" title="1">{
                        if _, exists := qrData["payment_amount"]; !exists </span><span class="cov8" title="1">{
                                return mcpgo.NewToolResultError(
                                        "payment_amount is required when fixed_amount is true"), nil
                        }</span>
                }

                // Create QR code using Razorpay SDK
                <span class="cov8" title="1">qrCode, err := client.QrCode.Create(qrData, nil)
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(
                                fmt.Sprintf("creating QR code failed: %s", err.Error())), nil
                }</span>

                <span class="cov8" title="1">return mcpgo.NewToolResultJSON(qrCode)</span>
        }

        <span class="cov8" title="1">return mcpgo.NewTool(
                "create_qr_code",
                "Create a new QR code in Razorpay that can be used to accept UPI payments",
                parameters,
                handler,
        )</span>
}

// FetchQRCode returns a tool that fetches a specific QR code by ID
func FetchQRCode(
        obs *observability.Observability,
        client *rzpsdk.Client,
) mcpgo.Tool <span class="cov8" title="1">{
        parameters := []mcpgo.ToolParameter{
                mcpgo.WithString(
                        "qr_code_id",
                        mcpgo.Description(
                                "Unique identifier of the QR Code to be retrieved"+
                                        "The QR code id should start with 'qr_'",
                        ),
                        mcpgo.Required(),
                ),
        }

        handler := func(
                ctx context.Context,
                r mcpgo.CallToolRequest,
        ) (*mcpgo.ToolResult, error) </span><span class="cov8" title="1">{
                client, err := getClientFromContextOrDefault(ctx, client)
                if err != nil </span><span class="cov0" title="0">{
                        return mcpgo.NewToolResultError(err.Error()), nil
                }</span>

                <span class="cov8" title="1">params := make(map[string]interface{})
                validator := NewValidator(&amp;r).
                        ValidateAndAddRequiredString(params, "qr_code_id")
                if result, err := validator.HandleErrorsIfAny(); result != nil </span><span class="cov8" title="1">{
                        return result, err
                }</span>
                <span class="cov8" title="1">qrCodeID := params["qr_code_id"].(string)

                // Fetch QR code by ID using Razorpay SDK
                qrCode, err := client.QrCode.Fetch(qrCodeID, nil, nil)
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(
                                fmt.Sprintf("fetching QR code failed: %s", err.Error())), nil
                }</span>

                <span class="cov8" title="1">return mcpgo.NewToolResultJSON(qrCode)</span>
        }

        <span class="cov8" title="1">return mcpgo.NewTool(
                "fetch_qr_code",
                "Fetch a QR code's details using it's ID",
                parameters,
                handler,
        )</span>
}

// FetchAllQRCodes returns a tool that fetches all QR codes
// with pagination support
func FetchAllQRCodes(
        obs *observability.Observability,
        client *rzpsdk.Client,
) mcpgo.Tool <span class="cov8" title="1">{
        parameters := []mcpgo.ToolParameter{
                mcpgo.WithNumber(
                        "from",
                        mcpgo.Description(
                                "Unix timestamp, in seconds, from when QR Codes are to be retrieved",
                        ),
                        mcpgo.Min(0),
                ),
                mcpgo.WithNumber(
                        "to",
                        mcpgo.Description(
                                "Unix timestamp, in seconds, till when QR Codes are to be retrieved",
                        ),
                        mcpgo.Min(0),
                ),
                mcpgo.WithNumber(
                        "count",
                        mcpgo.Description(
                                "Number of QR Codes to be retrieved (default: 10, max: 100)",
                        ),
                        mcpgo.Min(1),
                        mcpgo.Max(100),
                ),
                mcpgo.WithNumber(
                        "skip",
                        mcpgo.Description(
                                "Number of QR Codes to be skipped (default: 0)",
                        ),
                        mcpgo.Min(0),
                ),
        }

        handler := func(
                ctx context.Context,
                r mcpgo.CallToolRequest,
        ) (*mcpgo.ToolResult, error) </span><span class="cov8" title="1">{
                client, err := getClientFromContextOrDefault(ctx, client)
                if err != nil </span><span class="cov0" title="0">{
                        return mcpgo.NewToolResultError(err.Error()), nil
                }</span>

                <span class="cov8" title="1">fetchQROptions := make(map[string]interface{})

                validator := NewValidator(&amp;r).
                        ValidateAndAddOptionalInt(fetchQROptions, "from").
                        ValidateAndAddOptionalInt(fetchQROptions, "to").
                        ValidateAndAddPagination(fetchQROptions)

                if result, err := validator.HandleErrorsIfAny(); result != nil </span><span class="cov8" title="1">{
                        return result, err
                }</span>

                // Fetch QR codes using Razorpay SDK
                <span class="cov8" title="1">qrCodes, err := client.QrCode.All(fetchQROptions, nil)
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(
                                fmt.Sprintf("fetching QR codes failed: %s", err.Error())), nil
                }</span>

                <span class="cov8" title="1">return mcpgo.NewToolResultJSON(qrCodes)</span>
        }

        <span class="cov8" title="1">return mcpgo.NewTool(
                "fetch_all_qr_codes",
                "Fetch all QR codes with optional filtering and pagination",
                parameters,
                handler,
        )</span>
}

// FetchQRCodesByCustomerID returns a tool that fetches QR codes
// for a specific customer ID
func FetchQRCodesByCustomerID(
        obs *observability.Observability,
        client *rzpsdk.Client,
) mcpgo.Tool <span class="cov8" title="1">{
        parameters := []mcpgo.ToolParameter{
                mcpgo.WithString(
                        "customer_id",
                        mcpgo.Description(
                                "The unique identifier of the customer",
                        ),
                        mcpgo.Required(),
                ),
        }

        handler := func(
                ctx context.Context,
                r mcpgo.CallToolRequest,
        ) (*mcpgo.ToolResult, error) </span><span class="cov8" title="1">{
                client, err := getClientFromContextOrDefault(ctx, client)
                if err != nil </span><span class="cov0" title="0">{
                        return mcpgo.NewToolResultError(err.Error()), nil
                }</span>

                <span class="cov8" title="1">fetchQROptions := make(map[string]interface{})

                validator := NewValidator(&amp;r).
                        ValidateAndAddRequiredString(fetchQROptions, "customer_id")

                if result, err := validator.HandleErrorsIfAny(); result != nil </span><span class="cov8" title="1">{
                        return result, err
                }</span>

                // Fetch QR codes by customer ID using Razorpay SDK
                <span class="cov8" title="1">qrCodes, err := client.QrCode.All(fetchQROptions, nil)
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(
                                fmt.Sprintf("fetching QR codes failed: %s", err.Error())), nil
                }</span>

                <span class="cov8" title="1">return mcpgo.NewToolResultJSON(qrCodes)</span>
        }

        <span class="cov8" title="1">return mcpgo.NewTool(
                "fetch_qr_codes_by_customer_id",
                "Fetch all QR codes for a specific customer",
                parameters,
                handler,
        )</span>
}

// FetchQRCodesByPaymentID returns a tool that fetches QR codes
// for a specific payment ID
func FetchQRCodesByPaymentID(
        obs *observability.Observability,
        client *rzpsdk.Client,
) mcpgo.Tool <span class="cov8" title="1">{
        parameters := []mcpgo.ToolParameter{
                mcpgo.WithString(
                        "payment_id",
                        mcpgo.Description(
                                "The unique identifier of the payment"+
                                        "The payment id always should start with 'pay_'",
                        ),
                        mcpgo.Required(),
                ),
        }

        handler := func(
                ctx context.Context,
                r mcpgo.CallToolRequest,
        ) (*mcpgo.ToolResult, error) </span><span class="cov8" title="1">{
                client, err := getClientFromContextOrDefault(ctx, client)
                if err != nil </span><span class="cov0" title="0">{
                        return mcpgo.NewToolResultError(err.Error()), nil
                }</span>

                <span class="cov8" title="1">fetchQROptions := make(map[string]interface{})

                validator := NewValidator(&amp;r).
                        ValidateAndAddRequiredString(fetchQROptions, "payment_id")

                if result, err := validator.HandleErrorsIfAny(); result != nil </span><span class="cov8" title="1">{
                        return result, err
                }</span>

                // Fetch QR codes by payment ID using Razorpay SDK
                <span class="cov8" title="1">qrCodes, err := client.QrCode.All(fetchQROptions, nil)
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(
                                fmt.Sprintf("fetching QR codes failed: %s", err.Error())), nil
                }</span>

                <span class="cov8" title="1">return mcpgo.NewToolResultJSON(qrCodes)</span>
        }

        <span class="cov8" title="1">return mcpgo.NewTool(
                "fetch_qr_codes_by_payment_id",
                "Fetch all QR codes for a specific payment",
                parameters,
                handler,
        )</span>
}

// FetchPaymentsForQRCode returns a tool that fetches payments made on a QR code
func FetchPaymentsForQRCode(
        obs *observability.Observability,
        client *rzpsdk.Client,
) mcpgo.Tool <span class="cov8" title="1">{
        parameters := []mcpgo.ToolParameter{
                mcpgo.WithString(
                        "qr_code_id",
                        mcpgo.Description(
                                "The unique identifier of the QR Code to fetch payments for"+
                                        "The QR code id should start with 'qr_'",
                        ),
                        mcpgo.Required(),
                ),
                mcpgo.WithNumber(
                        "from",
                        mcpgo.Description(
                                "Unix timestamp, in seconds, from when payments are to be retrieved",
                        ),
                        mcpgo.Min(0),
                ),
                mcpgo.WithNumber(
                        "to",
                        mcpgo.Description(
                                "Unix timestamp, in seconds, till when payments are to be fetched",
                        ),
                        mcpgo.Min(0),
                ),
                mcpgo.WithNumber(
                        "count",
                        mcpgo.Description(
                                "Number of payments to be fetched (default: 10, max: 100)",
                        ),
                        mcpgo.Min(1),
                        mcpgo.Max(100),
                ),
                mcpgo.WithNumber(
                        "skip",
                        mcpgo.Description(
                                "Number of records to be skipped while fetching the payments",
                        ),
                        mcpgo.Min(0),
                ),
        }

        handler := func(
                ctx context.Context,
                r mcpgo.CallToolRequest,
        ) (*mcpgo.ToolResult, error) </span><span class="cov8" title="1">{
                client, err := getClientFromContextOrDefault(ctx, client)
                if err != nil </span><span class="cov0" title="0">{
                        return mcpgo.NewToolResultError(err.Error()), nil
                }</span>

                <span class="cov8" title="1">params := make(map[string]interface{})
                fetchQROptions := make(map[string]interface{})

                validator := NewValidator(&amp;r).
                        ValidateAndAddRequiredString(params, "qr_code_id").
                        ValidateAndAddOptionalInt(fetchQROptions, "from").
                        ValidateAndAddOptionalInt(fetchQROptions, "to").
                        ValidateAndAddOptionalInt(fetchQROptions, "count").
                        ValidateAndAddOptionalInt(fetchQROptions, "skip")

                if result, err := validator.HandleErrorsIfAny(); result != nil </span><span class="cov8" title="1">{
                        return result, err
                }</span>

                <span class="cov8" title="1">qrCodeID := params["qr_code_id"].(string)

                // Fetch payments for QR code using Razorpay SDK
                payments, err := client.QrCode.FetchPayments(qrCodeID, fetchQROptions, nil)
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(
                                fmt.Sprintf("fetching payments for QR code failed: %s", err.Error())), nil
                }</span>

                <span class="cov8" title="1">return mcpgo.NewToolResultJSON(payments)</span>
        }

        <span class="cov8" title="1">return mcpgo.NewTool(
                "fetch_payments_for_qr_code",
                "Fetch all payments made on a QR code",
                parameters,
                handler,
        )</span>
}

// CloseQRCode returns a tool that closes a specific QR code
func CloseQRCode(
        obs *observability.Observability,
        client *rzpsdk.Client,
) mcpgo.Tool <span class="cov8" title="1">{
        parameters := []mcpgo.ToolParameter{
                mcpgo.WithString(
                        "qr_code_id",
                        mcpgo.Description(
                                "Unique identifier of the QR Code to be closed"+
                                        "The QR code id should start with 'qr_'",
                        ),
                        mcpgo.Required(),
                ),
        }

        handler := func(
                ctx context.Context,
                r mcpgo.CallToolRequest,
        ) (*mcpgo.ToolResult, error) </span><span class="cov8" title="1">{
                client, err := getClientFromContextOrDefault(ctx, client)
                if err != nil </span><span class="cov0" title="0">{
                        return mcpgo.NewToolResultError(err.Error()), nil
                }</span>

                <span class="cov8" title="1">params := make(map[string]interface{})
                validator := NewValidator(&amp;r).
                        ValidateAndAddRequiredString(params, "qr_code_id")
                if result, err := validator.HandleErrorsIfAny(); result != nil </span><span class="cov8" title="1">{
                        return result, err
                }</span>
                <span class="cov8" title="1">qrCodeID := params["qr_code_id"].(string)

                // Close QR code by ID using Razorpay SDK
                qrCode, err := client.QrCode.Close(qrCodeID, nil, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return mcpgo.NewToolResultError(
                                fmt.Sprintf("closing QR code failed: %s", err.Error())), nil
                }</span>

                <span class="cov8" title="1">return mcpgo.NewToolResultJSON(qrCode)</span>
        }

        <span class="cov8" title="1">return mcpgo.NewTool(
                "close_qr_code",
                "Close a QR Code that's no longer needed",
                parameters,
                handler,
        )</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package razorpay

import (
        "context"
        "fmt"

        rzpsdk "github.com/razorpay/razorpay-go"

        "github.com/razorpay/razorpay-mcp-server/pkg/mcpgo"
        "github.com/razorpay/razorpay-mcp-server/pkg/observability"
)

// CreateRefund returns a tool that creates a normal refund for a payment
func CreateRefund(
        obs *observability.Observability,
        client *rzpsdk.Client,
) mcpgo.Tool <span class="cov8" title="1">{
        parameters := []mcpgo.ToolParameter{
                mcpgo.WithString(
                        "payment_id",
                        mcpgo.Description("Unique identifier of the payment which "+
                                "needs to be refunded. ID should have a pay_ prefix."),
                        mcpgo.Required(),
                ),
                mcpgo.WithNumber(
                        "amount",
                        mcpgo.Description("Payment amount in the smallest currency unit "+
                                "(e.g., for 295, use 29500)"),
                        mcpgo.Required(),
                        mcpgo.Min(100), // Minimum amount is 100 (1.00 in currency)
                ),
                mcpgo.WithString(
                        "speed",
                        mcpgo.Description("The speed at which the refund is to be "+
                                "processed. Default is 'normal'. For instant refunds, speed "+
                                "is set as 'optimum'."),
                ),
                mcpgo.WithObject(
                        "notes",
                        mcpgo.Description("Key-value pairs used to store additional "+
                                "information. A maximum of 15 key-value pairs can be included."),
                ),
                mcpgo.WithString(
                        "receipt",
                        mcpgo.Description("A unique identifier provided by you for "+
                                "your internal reference."),
                ),
        }

        handler := func(
                ctx context.Context,
                r mcpgo.CallToolRequest,
        ) (*mcpgo.ToolResult, error) </span><span class="cov8" title="1">{
                // Get client from context or use default
                client, err := getClientFromContextOrDefault(ctx, client)
                if err != nil </span><span class="cov0" title="0">{
                        return mcpgo.NewToolResultError(err.Error()), nil
                }</span>

                <span class="cov8" title="1">payload := make(map[string]interface{})
                data := make(map[string]interface{})

                validator := NewValidator(&amp;r).
                        ValidateAndAddRequiredString(payload, "payment_id").
                        ValidateAndAddRequiredFloat(payload, "amount").
                        ValidateAndAddOptionalString(data, "speed").
                        ValidateAndAddOptionalString(data, "receipt").
                        ValidateAndAddOptionalMap(data, "notes")

                if result, err := validator.HandleErrorsIfAny(); result != nil </span><span class="cov8" title="1">{
                        return result, err
                }</span>

                <span class="cov8" title="1">refund, err := client.Payment.Refund(
                        payload["payment_id"].(string),
                        int(payload["amount"].(float64)), data, nil)
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(
                                fmt.Sprintf("creating refund failed: %s", err.Error())), nil
                }</span>

                <span class="cov8" title="1">return mcpgo.NewToolResultJSON(refund)</span>
        }

        <span class="cov8" title="1">return mcpgo.NewTool(
                "create_refund",
                "Use this tool to create a normal refund for a payment. "+
                        "Amount should be in the smallest currency unit "+
                        "(e.g., for 295, use 29500)",
                parameters,
                handler,
        )</span>
}

// FetchRefund returns a tool that fetches a refund by ID
func FetchRefund(
        obs *observability.Observability,
        client *rzpsdk.Client,
) mcpgo.Tool <span class="cov8" title="1">{
        parameters := []mcpgo.ToolParameter{
                mcpgo.WithString(
                        "refund_id",
                        mcpgo.Description(
                                "Unique identifier of the refund which is to be retrieved. "+
                                        "ID should have a rfnd_ prefix."),
                        mcpgo.Required(),
                ),
        }

        handler := func(
                ctx context.Context,
                r mcpgo.CallToolRequest,
        ) (*mcpgo.ToolResult, error) </span><span class="cov8" title="1">{
                // Get client from context or use default
                client, err := getClientFromContextOrDefault(ctx, client)
                if err != nil </span><span class="cov0" title="0">{
                        return mcpgo.NewToolResultError(err.Error()), nil
                }</span>

                <span class="cov8" title="1">payload := make(map[string]interface{})

                validator := NewValidator(&amp;r).
                        ValidateAndAddRequiredString(payload, "refund_id")

                if result, err := validator.HandleErrorsIfAny(); result != nil </span><span class="cov8" title="1">{
                        return result, err
                }</span>

                <span class="cov8" title="1">refund, err := client.Refund.Fetch(payload["refund_id"].(string), nil, nil)
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(
                                fmt.Sprintf("fetching refund failed: %s", err.Error())), nil
                }</span>

                <span class="cov8" title="1">return mcpgo.NewToolResultJSON(refund)</span>
        }

        <span class="cov8" title="1">return mcpgo.NewTool(
                "fetch_refund",
                "Use this tool to retrieve the details of a specific refund using its id.",
                parameters,
                handler,
        )</span>
}

// UpdateRefund returns a tool that updates a refund's notes
func UpdateRefund(
        obs *observability.Observability,
        client *rzpsdk.Client,
) mcpgo.Tool <span class="cov8" title="1">{
        parameters := []mcpgo.ToolParameter{
                mcpgo.WithString(
                        "refund_id",
                        mcpgo.Description("Unique identifier of the refund which "+
                                "needs to be updated. ID should have a rfnd_ prefix."),
                        mcpgo.Required(),
                ),
                mcpgo.WithObject(
                        "notes",
                        mcpgo.Description("Key-value pairs used to store additional "+
                                "information. A maximum of 15 key-value pairs can be included, "+
                                "with each value not exceeding 256 characters."),
                        mcpgo.Required(),
                ),
        }

        handler := func(
                ctx context.Context,
                r mcpgo.CallToolRequest,
        ) (*mcpgo.ToolResult, error) </span><span class="cov8" title="1">{
                // Get client from context or use default
                client, err := getClientFromContextOrDefault(ctx, client)
                if err != nil </span><span class="cov0" title="0">{
                        return mcpgo.NewToolResultError(err.Error()), nil
                }</span>

                <span class="cov8" title="1">payload := make(map[string]interface{})
                data := make(map[string]interface{})

                validator := NewValidator(&amp;r).
                        ValidateAndAddRequiredString(payload, "refund_id").
                        ValidateAndAddRequiredMap(data, "notes")

                if result, err := validator.HandleErrorsIfAny(); result != nil </span><span class="cov8" title="1">{
                        return result, err
                }</span>

                <span class="cov8" title="1">refund, err := client.Refund.Update(payload["refund_id"].(string), data, nil)
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(
                                fmt.Sprintf("updating refund failed: %s", err.Error())), nil
                }</span>

                <span class="cov8" title="1">return mcpgo.NewToolResultJSON(refund)</span>
        }

        <span class="cov8" title="1">return mcpgo.NewTool(
                "update_refund",
                "Use this tool to update the notes for a specific refund. "+
                        "Only the notes field can be modified.",
                parameters,
                handler,
        )</span>
}

// FetchMultipleRefundsForPayment returns a tool that fetches multiple refunds
// for a payment
func FetchMultipleRefundsForPayment(
        obs *observability.Observability,
        client *rzpsdk.Client,
) mcpgo.Tool <span class="cov8" title="1">{
        parameters := []mcpgo.ToolParameter{
                mcpgo.WithString(
                        "payment_id",
                        mcpgo.Description("Unique identifier of the payment for which "+
                                "refunds are to be retrieved. ID should have a pay_ prefix."),
                        mcpgo.Required(),
                ),
                mcpgo.WithNumber(
                        "from",
                        mcpgo.Description("Unix timestamp at which the refunds were created."),
                ),
                mcpgo.WithNumber(
                        "to",
                        mcpgo.Description("Unix timestamp till which the refunds were created."),
                ),
                mcpgo.WithNumber(
                        "count",
                        mcpgo.Description("The number of refunds to fetch for the payment."),
                ),
                mcpgo.WithNumber(
                        "skip",
                        mcpgo.Description("The number of refunds to be skipped for the payment."),
                ),
        }

        handler := func(
                ctx context.Context,
                r mcpgo.CallToolRequest,
        ) (*mcpgo.ToolResult, error) </span><span class="cov8" title="1">{
                client, err := getClientFromContextOrDefault(ctx, client)
                if err != nil </span><span class="cov0" title="0">{
                        return mcpgo.NewToolResultError(err.Error()), nil
                }</span>

                <span class="cov8" title="1">fetchReq := make(map[string]interface{})
                fetchOptions := make(map[string]interface{})

                validator := NewValidator(&amp;r).
                        ValidateAndAddRequiredString(fetchReq, "payment_id").
                        ValidateAndAddOptionalInt(fetchOptions, "from").
                        ValidateAndAddOptionalInt(fetchOptions, "to").
                        ValidateAndAddPagination(fetchOptions)

                if result, err := validator.HandleErrorsIfAny(); result != nil </span><span class="cov8" title="1">{
                        return result, err
                }</span>

                <span class="cov8" title="1">refunds, err := client.Payment.FetchMultipleRefund(
                        fetchReq["payment_id"].(string), fetchOptions, nil)
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(
                                fmt.Sprintf("fetching multiple refunds failed: %s",
                                        err.Error())), nil
                }</span>

                <span class="cov8" title="1">return mcpgo.NewToolResultJSON(refunds)</span>
        }

        <span class="cov8" title="1">return mcpgo.NewTool(
                "fetch_multiple_refunds_for_payment",
                "Use this tool to retrieve multiple refunds for a payment. "+
                        "By default, only the last 10 refunds are returned.",
                parameters,
                handler,
        )</span>
}

// FetchSpecificRefundForPayment returns a tool that fetches a specific refund
// for a payment
func FetchSpecificRefundForPayment(
        obs *observability.Observability,
        client *rzpsdk.Client,
) mcpgo.Tool <span class="cov8" title="1">{
        parameters := []mcpgo.ToolParameter{
                mcpgo.WithString(
                        "payment_id",
                        mcpgo.Description("Unique identifier of the payment for which "+
                                "the refund has been made. ID should have a pay_ prefix."),
                        mcpgo.Required(),
                ),
                mcpgo.WithString(
                        "refund_id",
                        mcpgo.Description("Unique identifier of the refund to be retrieved. "+
                                "ID should have a rfnd_ prefix."),
                        mcpgo.Required(),
                ),
        }

        handler := func(
                ctx context.Context,
                r mcpgo.CallToolRequest,
        ) (*mcpgo.ToolResult, error) </span><span class="cov8" title="1">{
                client, err := getClientFromContextOrDefault(ctx, client)
                if err != nil </span><span class="cov0" title="0">{
                        return mcpgo.NewToolResultError(err.Error()), nil
                }</span>

                <span class="cov8" title="1">params := make(map[string]interface{})

                validator := NewValidator(&amp;r).
                        ValidateAndAddRequiredString(params, "payment_id").
                        ValidateAndAddRequiredString(params, "refund_id")

                if result, err := validator.HandleErrorsIfAny(); result != nil </span><span class="cov8" title="1">{
                        return result, err
                }</span>

                <span class="cov8" title="1">refund, err := client.Payment.FetchRefund(
                        params["payment_id"].(string),
                        params["refund_id"].(string),
                        nil, nil)
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(
                                fmt.Sprintf("fetching specific refund for payment failed: %s",
                                        err.Error())), nil
                }</span>

                <span class="cov8" title="1">return mcpgo.NewToolResultJSON(refund)</span>
        }

        <span class="cov8" title="1">return mcpgo.NewTool(
                "fetch_specific_refund_for_payment",
                "Use this tool to retrieve details of a specific refund made for a payment.",
                parameters,
                handler,
        )</span>
}

// FetchAllRefunds returns a tool that fetches all refunds with pagination
// support
func FetchAllRefunds(
        obs *observability.Observability,
        client *rzpsdk.Client,
) mcpgo.Tool <span class="cov8" title="1">{
        parameters := []mcpgo.ToolParameter{
                mcpgo.WithNumber(
                        "from",
                        mcpgo.Description("Unix timestamp at which the refunds were created"),
                ),
                mcpgo.WithNumber(
                        "to",
                        mcpgo.Description("Unix timestamp till which the refunds were created"),
                ),
                mcpgo.WithNumber(
                        "count",
                        mcpgo.Description("The number of refunds to fetch. "+
                                "You can fetch a maximum of 100 refunds"),
                ),
                mcpgo.WithNumber(
                        "skip",
                        mcpgo.Description("The number of refunds to be skipped"),
                ),
        }

        handler := func(
                ctx context.Context,
                r mcpgo.CallToolRequest,
        ) (*mcpgo.ToolResult, error) </span><span class="cov8" title="1">{
                client, err := getClientFromContextOrDefault(ctx, client)
                if err != nil </span><span class="cov0" title="0">{
                        return mcpgo.NewToolResultError(err.Error()), nil
                }</span>

                <span class="cov8" title="1">queryParams := make(map[string]interface{})

                validator := NewValidator(&amp;r).
                        ValidateAndAddOptionalInt(queryParams, "from").
                        ValidateAndAddOptionalInt(queryParams, "to").
                        ValidateAndAddPagination(queryParams)

                if result, err := validator.HandleErrorsIfAny(); result != nil </span><span class="cov8" title="1">{
                        return result, err
                }</span>

                <span class="cov8" title="1">refunds, err := client.Refund.All(queryParams, nil)
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(
                                fmt.Sprintf("fetching refunds failed: %s", err.Error())), nil
                }</span>

                <span class="cov8" title="1">return mcpgo.NewToolResultJSON(refunds)</span>
        }

        <span class="cov8" title="1">return mcpgo.NewTool(
                "fetch_all_refunds",
                "Use this tool to retrieve details of all refunds. "+
                        "By default, only the last 10 refunds are returned.",
                parameters,
                handler,
        )</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package razorpay

import (
        "context"
        "fmt"

        rzpsdk "github.com/razorpay/razorpay-go"

        "github.com/razorpay/razorpay-mcp-server/pkg/contextkey"
        "github.com/razorpay/razorpay-mcp-server/pkg/mcpgo"
        "github.com/razorpay/razorpay-mcp-server/pkg/observability"
)

func NewRzpMcpServer(
        obs *observability.Observability,
        client *rzpsdk.Client,
        enabledToolsets []string,
        readOnly bool,
        mcpOpts ...mcpgo.ServerOption,
) (mcpgo.Server, error) <span class="cov8" title="1">{
        // Validate required parameters
        if obs == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("observability is required")
        }</span>
        <span class="cov8" title="1">if client == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("razorpay client is required")
        }</span>

        // Set up default MCP options with Razorpay-specific hooks
        <span class="cov8" title="1">defaultOpts := []mcpgo.ServerOption{
                mcpgo.WithLogging(),
                mcpgo.WithResourceCapabilities(true, true),
                mcpgo.WithToolCapabilities(true),
                mcpgo.WithHooks(mcpgo.SetupHooks(obs)),
        }
        // Merge with user-provided options
        mcpOpts = append(defaultOpts, mcpOpts...)

        // Create server
        server := mcpgo.NewMcpServer("razorpay-mcp-server", "1.0.0", mcpOpts...)

        // Register Razorpay tools
        toolsets, err := NewToolSets(obs, client, enabledToolsets, readOnly)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create toolsets: %w", err)
        }</span>
        <span class="cov8" title="1">toolsets.RegisterTools(server)

        return server, nil</span>
}

// getClientFromContextOrDefault returns either the provided default
// client or gets one from context.
func getClientFromContextOrDefault(
        ctx context.Context,
        defaultClient *rzpsdk.Client,
) (*rzpsdk.Client, error) <span class="cov8" title="1">{
        if defaultClient != nil </span><span class="cov8" title="1">{
                return defaultClient, nil
        }</span>

        <span class="cov8" title="1">clientInterface := contextkey.ClientFromContext(ctx)
        if clientInterface == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no client found in context")
        }</span>

        <span class="cov8" title="1">client, ok := clientInterface.(*rzpsdk.Client)
        if !ok </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid client type in context")
        }</span>

        <span class="cov8" title="1">return client, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package razorpay

import (
        "context"
        "fmt"

        rzpsdk "github.com/razorpay/razorpay-go"

        "github.com/razorpay/razorpay-mcp-server/pkg/mcpgo"
        "github.com/razorpay/razorpay-mcp-server/pkg/observability"
)

// FetchSettlement returns a tool that fetches a settlement by ID
func FetchSettlement(
        obs *observability.Observability,
        client *rzpsdk.Client,
) mcpgo.Tool <span class="cov8" title="1">{
        parameters := []mcpgo.ToolParameter{
                mcpgo.WithString(
                        "settlement_id",
                        mcpgo.Description("The ID of the settlement to fetch."+
                                "ID starts with the 'setl_'"),
                        mcpgo.Required(),
                ),
        }

        handler := func(
                ctx context.Context,
                r mcpgo.CallToolRequest,
        ) (*mcpgo.ToolResult, error) </span><span class="cov8" title="1">{
                client, err := getClientFromContextOrDefault(ctx, client)
                if err != nil </span><span class="cov0" title="0">{
                        return mcpgo.NewToolResultError(err.Error()), nil
                }</span>

                // Create a parameters map to collect validated parameters
                <span class="cov8" title="1">fetchSettlementOptions := make(map[string]interface{})

                // Validate using fluent validator
                validator := NewValidator(&amp;r).
                        ValidateAndAddRequiredString(fetchSettlementOptions, "settlement_id")

                if result, err := validator.HandleErrorsIfAny(); result != nil </span><span class="cov8" title="1">{
                        return result, err
                }</span>

                <span class="cov8" title="1">settlementID := fetchSettlementOptions["settlement_id"].(string)
                settlement, err := client.Settlement.Fetch(settlementID, nil, nil)
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(
                                fmt.Sprintf("fetching settlement failed: %s", err.Error())), nil
                }</span>

                <span class="cov8" title="1">return mcpgo.NewToolResultJSON(settlement)</span>
        }

        <span class="cov8" title="1">return mcpgo.NewTool(
                "fetch_settlement_with_id",
                "Fetch details of a specific settlement using its ID",
                parameters,
                handler,
        )</span>
}

// FetchSettlementRecon returns a tool that fetches settlement
// reconciliation reports
func FetchSettlementRecon(
        obs *observability.Observability,
        client *rzpsdk.Client,
) mcpgo.Tool <span class="cov8" title="1">{
        parameters := []mcpgo.ToolParameter{
                mcpgo.WithNumber(
                        "year",
                        mcpgo.Description("Year for which the settlement report is "+
                                "requested (YYYY format)"),
                        mcpgo.Required(),
                ),
                mcpgo.WithNumber(
                        "month",
                        mcpgo.Description("Month for which the settlement report is "+
                                "requested (MM format)"),
                        mcpgo.Required(),
                ),
                mcpgo.WithNumber(
                        "day",
                        mcpgo.Description("Optional: Day for which the settlement report is "+
                                "requested (DD format)"),
                ),
                mcpgo.WithNumber(
                        "count",
                        mcpgo.Description("Optional: Number of records to fetch "+
                                "(default: 10, max: 100)"),
                ),
                mcpgo.WithNumber(
                        "skip",
                        mcpgo.Description("Optional: Number of records to skip for pagination"),
                ),
        }

        handler := func(
                ctx context.Context,
                r mcpgo.CallToolRequest,
        ) (*mcpgo.ToolResult, error) </span><span class="cov8" title="1">{
                client, err := getClientFromContextOrDefault(ctx, client)
                if err != nil </span><span class="cov0" title="0">{
                        return mcpgo.NewToolResultError(err.Error()), nil
                }</span>

                // Create a parameters map to collect validated parameters
                <span class="cov8" title="1">fetchReconOptions := make(map[string]interface{})

                // Validate using fluent validator
                validator := NewValidator(&amp;r).
                        ValidateAndAddRequiredInt(fetchReconOptions, "year").
                        ValidateAndAddRequiredInt(fetchReconOptions, "month").
                        ValidateAndAddOptionalInt(fetchReconOptions, "day").
                        ValidateAndAddPagination(fetchReconOptions)

                if result, err := validator.HandleErrorsIfAny(); result != nil </span><span class="cov8" title="1">{
                        return result, err
                }</span>

                <span class="cov8" title="1">report, err := client.Settlement.Reports(fetchReconOptions, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return mcpgo.NewToolResultError(
                                fmt.Sprintf("fetching settlement reconciliation report failed: %s",
                                        err.Error())), nil
                }</span>

                <span class="cov8" title="1">return mcpgo.NewToolResultJSON(report)</span>
        }

        <span class="cov8" title="1">return mcpgo.NewTool(
                "fetch_settlement_recon_details",
                "Fetch settlement reconciliation report for a specific time period",
                parameters,
                handler,
        )</span>
}

// FetchAllSettlements returns a tool to fetch multiple settlements with
// filtering and pagination
func FetchAllSettlements(
        obs *observability.Observability,
        client *rzpsdk.Client,
) mcpgo.Tool <span class="cov8" title="1">{
        parameters := []mcpgo.ToolParameter{
                // Pagination parameters
                mcpgo.WithNumber(
                        "count",
                        mcpgo.Description("Number of settlement records to fetch "+
                                "(default: 10, max: 100)"),
                        mcpgo.Min(1),
                        mcpgo.Max(100),
                ),
                mcpgo.WithNumber(
                        "skip",
                        mcpgo.Description("Number of settlement records to skip (default: 0)"),
                        mcpgo.Min(0),
                ),
                // Time range filters
                mcpgo.WithNumber(
                        "from",
                        mcpgo.Description("Unix timestamp (in seconds) from when "+
                                "settlements are to be fetched"),
                        mcpgo.Min(0),
                ),
                mcpgo.WithNumber(
                        "to",
                        mcpgo.Description("Unix timestamp (in seconds) up till when "+
                                "settlements are to be fetched"),
                        mcpgo.Min(0),
                ),
        }

        handler := func(
                ctx context.Context,
                r mcpgo.CallToolRequest,
        ) (*mcpgo.ToolResult, error) </span><span class="cov8" title="1">{
                client, err := getClientFromContextOrDefault(ctx, client)
                if err != nil </span><span class="cov0" title="0">{
                        return mcpgo.NewToolResultError(err.Error()), nil
                }</span>

                // Create parameters map to collect validated parameters
                <span class="cov8" title="1">fetchAllSettlementsOptions := make(map[string]interface{})

                // Validate using fluent validator
                validator := NewValidator(&amp;r).
                        ValidateAndAddPagination(fetchAllSettlementsOptions).
                        ValidateAndAddOptionalInt(fetchAllSettlementsOptions, "from").
                        ValidateAndAddOptionalInt(fetchAllSettlementsOptions, "to")

                if result, err := validator.HandleErrorsIfAny(); result != nil </span><span class="cov0" title="0">{
                        return result, err
                }</span>

                // Fetch all settlements using Razorpay SDK
                <span class="cov8" title="1">settlements, err := client.Settlement.All(fetchAllSettlementsOptions, nil)
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(
                                fmt.Sprintf("fetching settlements failed: %s", err.Error())), nil
                }</span>

                <span class="cov8" title="1">return mcpgo.NewToolResultJSON(settlements)</span>
        }

        <span class="cov8" title="1">return mcpgo.NewTool(
                "fetch_all_settlements",
                "Fetch all settlements with optional filtering and pagination",
                parameters,
                handler,
        )</span>
}

// CreateInstantSettlement returns a tool that creates an instant settlement
func CreateInstantSettlement(
        obs *observability.Observability,
        client *rzpsdk.Client,
) mcpgo.Tool <span class="cov8" title="1">{
        parameters := []mcpgo.ToolParameter{
                mcpgo.WithNumber(
                        "amount",
                        mcpgo.Description("The amount you want to get settled instantly in amount in the smallest "+ //nolint:lll
                                "currency sub-unit (e.g., for 295, use 29500)"),
                        mcpgo.Required(),
                        mcpgo.Min(200), // Minimum amount is 200 (2)
                ),
                mcpgo.WithBoolean(
                        "settle_full_balance",
                        mcpgo.Description("If true, Razorpay will settle the maximum amount "+
                                "possible and ignore amount parameter"),
                        mcpgo.DefaultValue(false),
                ),
                mcpgo.WithString(
                        "description",
                        mcpgo.Description("Custom note for the instant settlement."),
                        mcpgo.Max(30),
                        mcpgo.Pattern("^[a-zA-Z0-9 ]*$"),
                ),
                mcpgo.WithObject(
                        "notes",
                        mcpgo.Description("Key-value pairs for additional information. "+
                                "Max 15 pairs, 256 chars each"),
                        mcpgo.MaxProperties(15),
                ),
        }

        handler := func(
                ctx context.Context,
                r mcpgo.CallToolRequest,
        ) (*mcpgo.ToolResult, error) </span><span class="cov8" title="1">{
                client, err := getClientFromContextOrDefault(ctx, client)
                if err != nil </span><span class="cov0" title="0">{
                        return mcpgo.NewToolResultError(err.Error()), nil
                }</span>

                // Create parameters map to collect validated parameters
                <span class="cov8" title="1">createInstantSettlementReq := make(map[string]interface{})

                // Validate using fluent validator
                validator := NewValidator(&amp;r).
                        ValidateAndAddRequiredInt(createInstantSettlementReq, "amount").
                        ValidateAndAddOptionalBool(createInstantSettlementReq, "settle_full_balance"). // nolint:lll
                        ValidateAndAddOptionalString(createInstantSettlementReq, "description").
                        ValidateAndAddOptionalMap(createInstantSettlementReq, "notes")

                if result, err := validator.HandleErrorsIfAny(); result != nil </span><span class="cov8" title="1">{
                        return result, err
                }</span>

                // Create the instant settlement
                <span class="cov8" title="1">settlement, err := client.Settlement.CreateOnDemandSettlement(
                        createInstantSettlementReq, nil)
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(
                                fmt.Sprintf("creating instant settlement failed: %s",
                                        err.Error())), nil
                }</span>

                <span class="cov8" title="1">return mcpgo.NewToolResultJSON(settlement)</span>
        }

        <span class="cov8" title="1">return mcpgo.NewTool(
                "create_instant_settlement",
                "Create an instant settlement to get funds transferred to your bank account", // nolint:lll
                parameters,
                handler,
        )</span>
}

// FetchAllInstantSettlements returns a tool to fetch all instant settlements
// with filtering and pagination
func FetchAllInstantSettlements(
        obs *observability.Observability,
        client *rzpsdk.Client,
) mcpgo.Tool <span class="cov8" title="1">{
        parameters := []mcpgo.ToolParameter{
                // Pagination parameters
                mcpgo.WithNumber(
                        "count",
                        mcpgo.Description("Number of instant settlement records to fetch "+
                                "(default: 10, max: 100)"),
                        mcpgo.Min(1),
                        mcpgo.Max(100),
                ),
                mcpgo.WithNumber(
                        "skip",
                        mcpgo.Description("Number of instant settlement records to skip (default: 0)"), //nolint:lll
                        mcpgo.Min(0),
                ),
                // Time range filters
                mcpgo.WithNumber(
                        "from",
                        mcpgo.Description("Unix timestamp (in seconds) from when "+
                                "instant settlements are to be fetched"),
                        mcpgo.Min(0),
                ),
                mcpgo.WithNumber(
                        "to",
                        mcpgo.Description("Unix timestamp (in seconds) up till when "+
                                "instant settlements are to be fetched"),
                        mcpgo.Min(0),
                ),
                // Expand parameter for payout details
                mcpgo.WithArray(
                        "expand",
                        mcpgo.Description("Pass this if you want to fetch payout details "+
                                "as part of the response for all instant settlements. "+
                                "Supported values: ondemand_payouts"),
                ),
        }

        handler := func(
                ctx context.Context,
                r mcpgo.CallToolRequest,
        ) (*mcpgo.ToolResult, error) </span><span class="cov8" title="1">{
                client, err := getClientFromContextOrDefault(ctx, client)
                if err != nil </span><span class="cov0" title="0">{
                        return mcpgo.NewToolResultError(err.Error()), nil
                }</span>

                // Create parameters map to collect validated parameters
                <span class="cov8" title="1">options := make(map[string]interface{})

                // Validate using fluent validator
                validator := NewValidator(&amp;r).
                        ValidateAndAddPagination(options).
                        ValidateAndAddExpand(options).
                        ValidateAndAddOptionalInt(options, "from").
                        ValidateAndAddOptionalInt(options, "to")

                if result, err := validator.HandleErrorsIfAny(); result != nil </span><span class="cov0" title="0">{
                        return result, err
                }</span>

                // Fetch all instant settlements using Razorpay SDK
                <span class="cov8" title="1">settlements, err := client.Settlement.FetchAllOnDemandSettlement(options, nil)
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(
                                fmt.Sprintf("fetching instant settlements failed: %s", err.Error())), nil
                }</span>

                <span class="cov8" title="1">return mcpgo.NewToolResultJSON(settlements)</span>
        }

        <span class="cov8" title="1">return mcpgo.NewTool(
                "fetch_all_instant_settlements",
                "Fetch all instant settlements with optional filtering, pagination, and payout details", //nolint:lll
                parameters,
                handler,
        )</span>
}

// FetchInstantSettlement returns a tool that fetches instant settlement by ID
func FetchInstantSettlement(
        obs *observability.Observability,
        client *rzpsdk.Client,
) mcpgo.Tool <span class="cov8" title="1">{
        parameters := []mcpgo.ToolParameter{
                mcpgo.WithString(
                        "settlement_id",
                        mcpgo.Description("The ID of the instant settlement to fetch. "+
                                "ID starts with 'setlod_'"),
                        mcpgo.Required(),
                ),
        }

        handler := func(
                ctx context.Context,
                r mcpgo.CallToolRequest,
        ) (*mcpgo.ToolResult, error) </span><span class="cov8" title="1">{
                client, err := getClientFromContextOrDefault(ctx, client)
                if err != nil </span><span class="cov0" title="0">{
                        return mcpgo.NewToolResultError(err.Error()), nil
                }</span>

                // Create parameters map to collect validated parameters
                <span class="cov8" title="1">params := make(map[string]interface{})

                // Validate using fluent validator
                validator := NewValidator(&amp;r).
                        ValidateAndAddRequiredString(params, "settlement_id")

                if result, err := validator.HandleErrorsIfAny(); result != nil </span><span class="cov8" title="1">{
                        return result, err
                }</span>

                <span class="cov8" title="1">settlementID := params["settlement_id"].(string)

                // Fetch the instant settlement by ID using SDK
                settlement, err := client.Settlement.FetchOnDemandSettlementById(
                        settlementID, nil, nil)
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(
                                fmt.Sprintf("fetching instant settlement failed: %s", err.Error())), nil
                }</span>

                <span class="cov8" title="1">return mcpgo.NewToolResultJSON(settlement)</span>
        }

        <span class="cov8" title="1">return mcpgo.NewTool(
                "fetch_instant_settlement_with_id",
                "Fetch details of a specific instant settlement using its ID",
                parameters,
                handler,
        )</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package razorpay

import (
        "context"
        "encoding/json"
        "net/http"
        "net/http/httptest"
        "testing"

        "github.com/go-test/deep"
        "github.com/stretchr/testify/assert"

        rzpsdk "github.com/razorpay/razorpay-go"

        "github.com/razorpay/razorpay-mcp-server/pkg/log"
        "github.com/razorpay/razorpay-mcp-server/pkg/mcpgo"
        "github.com/razorpay/razorpay-mcp-server/pkg/observability"
)

// RazorpayToolTestCase defines a common structure for Razorpay tool tests
type RazorpayToolTestCase struct {
        Name           string
        Request        map[string]interface{}
        MockHttpClient func() (*http.Client, *httptest.Server)
        ExpectError    bool
        ExpectedResult map[string]interface{}
        ExpectedErrMsg string
}

// CreateTestObservability creates an observability stack suitable for testing
func CreateTestObservability() *observability.Observability <span class="cov8" title="1">{
        // Create a logger that discards output
        _, logger := log.New(context.Background(), log.NewConfig(
                log.WithMode(log.ModeStdio)),
        )
        return &amp;observability.Observability{
                Logger: logger,
        }
}</span>

// createMCPRequest creates a CallToolRequest with the given arguments
func createMCPRequest(args any) mcpgo.CallToolRequest <span class="cov8" title="1">{
        return mcpgo.CallToolRequest{
                Arguments: args,
        }
}</span>

// newMockRzpClient configures a Razorpay client with a mock
// HTTP client for testing. It returns the configured client
// and the mock server (which should be closed by the caller)
func newMockRzpClient(
        mockHttpClient func() (*http.Client, *httptest.Server),
) (*rzpsdk.Client, *httptest.Server) <span class="cov8" title="1">{
        rzpMockClient := rzpsdk.NewClient("sample_key", "sample_secret")

        var mockServer *httptest.Server
        if mockHttpClient != nil </span><span class="cov8" title="1">{
                var client *http.Client
                client, mockServer = mockHttpClient()

                // This Request object is shared by reference across all
                // API resources in the client
                req := rzpMockClient.Order.Request
                req.BaseURL = mockServer.URL
                req.HTTPClient = client
        }</span>

        <span class="cov8" title="1">return rzpMockClient, mockServer</span>
}

// runToolTest executes a common test pattern for Razorpay tools
func runToolTest(
        t *testing.T,
        tc RazorpayToolTestCase,
        toolCreator func(*observability.Observability, *rzpsdk.Client) mcpgo.Tool,
        objectType string,
) <span class="cov8" title="1">{
        mockRzpClient, mockServer := newMockRzpClient(tc.MockHttpClient)
        if mockServer != nil </span><span class="cov8" title="1">{
                defer mockServer.Close()
        }</span>

        <span class="cov8" title="1">obs := CreateTestObservability()
        tool := toolCreator(obs, mockRzpClient)

        request := createMCPRequest(tc.Request)
        result, err := tool.GetHandler()(context.Background(), request)

        assert.NoError(t, err)

        if tc.ExpectError </span><span class="cov8" title="1">{
                assert.NotNil(t, result)
                assert.Contains(t, result.Text, tc.ExpectedErrMsg)
                return
        }</span>

        <span class="cov8" title="1">assert.NotNil(t, result)

        var returnedObj map[string]interface{}
        err = json.Unmarshal([]byte(result.Text), &amp;returnedObj)
        assert.NoError(t, err)

        if diff := deep.Equal(tc.ExpectedResult, returnedObj); diff != nil </span><span class="cov0" title="0">{
                t.Errorf("%s mismatch: %s", objectType, diff)
        }</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package razorpay

import (
        "context"
        "fmt"

        rzpsdk "github.com/razorpay/razorpay-go"
        "github.com/razorpay/razorpay-go/constants"

        "github.com/razorpay/razorpay-mcp-server/pkg/mcpgo"
        "github.com/razorpay/razorpay-mcp-server/pkg/observability"
)

// FetchSavedPaymentMethods returns a tool that fetches saved cards
// using contact number
func FetchSavedPaymentMethods(
        obs *observability.Observability,
        client *rzpsdk.Client,
) mcpgo.Tool <span class="cov8" title="1">{
        parameters := []mcpgo.ToolParameter{
                mcpgo.WithString(
                        "contact",
                        mcpgo.Description(
                                "Contact number of the customer to fetch all saved payment methods for. "+
                                        "For example, 9876543210 or +919876543210"),
                        mcpgo.Required(),
                ),
        }

        handler := func(
                ctx context.Context,
                r mcpgo.CallToolRequest,
        ) (*mcpgo.ToolResult, error) </span><span class="cov8" title="1">{
                // Get client from context or use default
                client, err := getClientFromContextOrDefault(ctx, client)
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(err.Error()), nil
                }</span>

                <span class="cov8" title="1">validator := NewValidator(&amp;r)

                // Validate required contact parameter
                contactValue, err := extractValueGeneric[string](&amp;r, "contact", true)
                if err != nil </span><span class="cov8" title="1">{
                        validator = validator.addError(err)
                }</span> else<span class="cov8" title="1"> if contactValue == nil || *contactValue == "" </span><span class="cov8" title="1">{
                        validator = validator.addError(
                                fmt.Errorf("missing required parameter: contact"))
                }</span>
                <span class="cov8" title="1">if result, err := validator.HandleErrorsIfAny(); result != nil </span><span class="cov8" title="1">{
                        return result, err
                }</span>
                <span class="cov8" title="1">contact := *contactValue
                customerData := map[string]interface{}{
                        "contact":       contact,
                        "fail_existing": "0", // Get existing customer if exists
                }

                // Create/get customer using Razorpay SDK
                customer, err := client.Customer.Create(customerData, nil)
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(
                                fmt.Sprintf(
                                        "Failed to create/fetch customer with contact %s: %v", contact, err,
                                )), nil
                }</span>

                <span class="cov8" title="1">customerID, ok := customer["id"].(string)
                if !ok </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError("Customer ID not found in response"), nil
                }</span>

                <span class="cov8" title="1">url := fmt.Sprintf("/%s/customers/%s/tokens",
                        constants.VERSION_V1, customerID)

                // Make the API request to get tokens
                tokensResponse, err := client.Request.Get(url, nil, nil)
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(
                                fmt.Sprintf(
                                        "Failed to fetch saved payment methods for customer %s: %v",
                                        customerID,
                                        err,
                                )), nil
                }</span>

                <span class="cov8" title="1">result := map[string]interface{}{
                        "customer":              customer,
                        "saved_payment_methods": tokensResponse,
                }
                return mcpgo.NewToolResultJSON(result)</span>
        }

        <span class="cov8" title="1">return mcpgo.NewTool(
                "fetch_tokens",
                "Get all saved payment methods (cards, UPI)"+
                        " for a contact number. "+
                        "This tool first finds or creates a"+
                        " customer with the given contact number, "+
                        "then fetches all saved payment tokens "+
                        "associated with that customer including "+
                        "credit/debit cards, UPI IDs, digital wallets,"+
                        " and other tokenized payment instruments.",
                parameters,
                handler,
        )</span>
}

// RevokeToken returns a tool that revokes a saved payment token
func RevokeToken(
        obs *observability.Observability,
        client *rzpsdk.Client,
) mcpgo.Tool <span class="cov8" title="1">{
        parameters := []mcpgo.ToolParameter{
                mcpgo.WithString(
                        "customer_id",
                        mcpgo.Description(
                                "Customer ID for which the token should be revoked. "+
                                        "Must start with 'cust_' followed by alphanumeric characters. "+
                                        "Example: 'cust_xxx'"),
                        mcpgo.Required(),
                ),
                mcpgo.WithString(
                        "token_id",
                        mcpgo.Description(
                                "Token ID of the saved payment method to be revoked. "+
                                        "Must start with 'token_' followed by alphanumeric characters. "+
                                        "Example: 'token_xxx'"),
                        mcpgo.Required(),
                ),
        }

        handler := func(
                ctx context.Context,
                r mcpgo.CallToolRequest,
        ) (*mcpgo.ToolResult, error) </span><span class="cov8" title="1">{
                // Get client from context or use default
                client, err := getClientFromContextOrDefault(ctx, client)
                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(err.Error()), nil
                }</span>

                <span class="cov8" title="1">validator := NewValidator(&amp;r)

                // Validate required customer_id parameter
                customerIDValue, err := extractValueGeneric[string](&amp;r, "customer_id", true)
                if err != nil </span><span class="cov8" title="1">{
                        validator = validator.addError(err)
                }</span> else<span class="cov8" title="1"> if customerIDValue == nil || *customerIDValue == "" </span><span class="cov8" title="1">{
                        validator = validator.addError(
                                fmt.Errorf("missing required parameter: customer_id"))
                }</span>
                <span class="cov8" title="1">if result, err := validator.HandleErrorsIfAny(); result != nil </span><span class="cov8" title="1">{
                        return result, err
                }</span>
                <span class="cov8" title="1">customerID := *customerIDValue

                // Validate required token_id parameter
                tokenIDValue, err := extractValueGeneric[string](&amp;r, "token_id", true)
                if err != nil </span><span class="cov8" title="1">{
                        validator = validator.addError(err)
                }</span> else<span class="cov8" title="1"> if tokenIDValue == nil || *tokenIDValue == "" </span><span class="cov8" title="1">{
                        validator = validator.addError(
                                fmt.Errorf("missing required parameter: token_id"))
                }</span>
                <span class="cov8" title="1">if result, err := validator.HandleErrorsIfAny(); result != nil </span><span class="cov8" title="1">{
                        return result, err
                }</span>
                <span class="cov8" title="1">tokenID := *tokenIDValue

                url := fmt.Sprintf(
                        "/%s%s/%s/tokens/%s/cancel",
                        constants.VERSION_V1,
                        constants.CUSTOMER_URL,
                        customerID,
                        tokenID,
                )
                response, err := client.Token.Request.Put(url, nil, nil)

                if err != nil </span><span class="cov8" title="1">{
                        return mcpgo.NewToolResultError(
                                fmt.Sprintf(
                                        "Failed to revoke token %s for customer %s: %v",
                                        tokenID,
                                        customerID,
                                        err,
                                )), nil
                }</span>

                <span class="cov8" title="1">return mcpgo.NewToolResultJSON(response)</span>
        }

        <span class="cov8" title="1">return mcpgo.NewTool(
                "revoke_token",
                "Revoke a saved payment method (token) for a customer. "+
                        "This tool revokes the specified token "+
                        "associated with the given customer ID. "+
                        "Once revoked, the token cannot be used for future payments.",
                parameters,
                handler,
        )</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package razorpay

import (
        rzpsdk "github.com/razorpay/razorpay-go"

        "github.com/razorpay/razorpay-mcp-server/pkg/observability"
        "github.com/razorpay/razorpay-mcp-server/pkg/toolsets"
)

func NewToolSets(
        obs *observability.Observability,
        client *rzpsdk.Client,
        enabledToolsets []string,
        readOnly bool,
) (*toolsets.ToolsetGroup, error) <span class="cov8" title="1">{
        // Create a new toolset group
        toolsetGroup := toolsets.NewToolsetGroup(readOnly)

        // Create toolsets
        payments := toolsets.NewToolset("payments", "Razorpay Payments related tools").
                AddReadTools(
                        FetchPayment(obs, client),
                        FetchPaymentCardDetails(obs, client),
                        FetchAllPayments(obs, client),
                ).
                AddWriteTools(
                        CapturePayment(obs, client),
                        UpdatePayment(obs, client),
                        InitiatePayment(obs, client),
                        ResendOtp(obs, client),
                        SubmitOtp(obs, client),
                )

        paymentLinks := toolsets.NewToolset(
                "payment_links",
                "Razorpay Payment Links related tools").
                AddReadTools(
                        FetchPaymentLink(obs, client),
                        FetchAllPaymentLinks(obs, client),
                ).
                AddWriteTools(
                        CreatePaymentLink(obs, client),
                        CreateUpiPaymentLink(obs, client),
                        ResendPaymentLinkNotification(obs, client),
                        UpdatePaymentLink(obs, client),
                )

        orders := toolsets.NewToolset("orders", "Razorpay Orders related tools").
                AddReadTools(
                        FetchOrder(obs, client),
                        FetchAllOrders(obs, client),
                        FetchOrderPayments(obs, client),
                ).
                AddWriteTools(
                        CreateOrder(obs, client),
                        UpdateOrder(obs, client),
                )

        refunds := toolsets.NewToolset("refunds", "Razorpay Refunds related tools").
                AddReadTools(
                        FetchRefund(obs, client),
                        FetchMultipleRefundsForPayment(obs, client),
                        FetchSpecificRefundForPayment(obs, client),
                        FetchAllRefunds(obs, client),
                ).
                AddWriteTools(
                        CreateRefund(obs, client),
                        UpdateRefund(obs, client),
                )

        payouts := toolsets.NewToolset("payouts", "Razorpay Payouts related tools").
                AddReadTools(
                        FetchPayout(obs, client),
                        FetchAllPayouts(obs, client),
                )

        qrCodes := toolsets.NewToolset("qr_codes", "Razorpay QR Codes related tools").
                AddReadTools(
                        FetchQRCode(obs, client),
                        FetchAllQRCodes(obs, client),
                        FetchQRCodesByCustomerID(obs, client),
                        FetchQRCodesByPaymentID(obs, client),
                        FetchPaymentsForQRCode(obs, client),
                ).
                AddWriteTools(
                        CreateQRCode(obs, client),
                        CloseQRCode(obs, client),
                )

        settlements := toolsets.NewToolset("settlements",
                "Razorpay Settlements related tools").
                AddReadTools(
                        FetchSettlement(obs, client),
                        FetchSettlementRecon(obs, client),
                        FetchAllSettlements(obs, client),
                        FetchAllInstantSettlements(obs, client),
                        FetchInstantSettlement(obs, client),
                ).
                AddWriteTools(
                        CreateInstantSettlement(obs, client),
                )

        // Add the single custom tool to an existing toolset
        payments.AddReadTools(FetchSavedPaymentMethods(obs, client)).
                AddWriteTools(RevokeToken(obs, client))

        // Add toolsets to the group
        toolsetGroup.AddToolset(payments)
        toolsetGroup.AddToolset(paymentLinks)
        toolsetGroup.AddToolset(orders)
        toolsetGroup.AddToolset(refunds)
        toolsetGroup.AddToolset(payouts)
        toolsetGroup.AddToolset(qrCodes)
        toolsetGroup.AddToolset(settlements)

        // Enable the requested features
        if err := toolsetGroup.EnableToolsets(enabledToolsets); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return toolsetGroup, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package razorpay

import (
        "encoding/json"
        "errors"
        "strings"
        "time"

        "github.com/razorpay/razorpay-mcp-server/pkg/mcpgo"
)

// Validator provides a fluent interface for validating parameters
// and collecting errors
type Validator struct {
        request *mcpgo.CallToolRequest
        errors  []error
}

// NewValidator creates a new validator for the given request
func NewValidator(r *mcpgo.CallToolRequest) *Validator <span class="cov8" title="1">{
        return &amp;Validator{
                request: r,
                errors:  []error{},
        }
}</span>

// addError adds a non-nil error to the collection
func (v *Validator) addError(err error) *Validator <span class="cov8" title="1">{
        if err != nil </span><span class="cov8" title="1">{
                v.errors = append(v.errors, err)
        }</span>
        <span class="cov8" title="1">return v</span>
}

// HasErrors returns true if there are any validation errors
func (v *Validator) HasErrors() bool <span class="cov8" title="1">{
        return len(v.errors) &gt; 0
}</span>

// HandleErrorsIfAny formats all errors and returns an appropriate tool result
func (v *Validator) HandleErrorsIfAny() (*mcpgo.ToolResult, error) <span class="cov8" title="1">{
        if v.HasErrors() </span><span class="cov8" title="1">{
                messages := make([]string, 0, len(v.errors))
                for _, err := range v.errors </span><span class="cov8" title="1">{
                        messages = append(messages, err.Error())
                }</span>
                <span class="cov8" title="1">errorMsg := "Validation errors:\n- " + strings.Join(messages, "\n- ")
                return mcpgo.NewToolResultError(errorMsg), nil</span>
        }
        <span class="cov8" title="1">return nil, nil</span>
}

// extractValueGeneric is a standalone generic function to extract a parameter
// of type T
func extractValueGeneric[T any](
        request *mcpgo.CallToolRequest,
        name string,
        required bool,
) (*T, error) <span class="cov8" title="1">{
        // Type assert Arguments from any to map[string]interface{}
        args, ok := request.Arguments.(map[string]interface{})
        if !ok </span><span class="cov8" title="1">{
                return nil, errors.New("invalid arguments type")
        }</span>

        <span class="cov8" title="1">val, ok := args[name]
        if !ok || val == nil </span><span class="cov8" title="1">{
                if required </span><span class="cov8" title="1">{
                        return nil, errors.New("missing required parameter: " + name)
                }</span>
                <span class="cov8" title="1">return nil, nil</span> // Not an error for optional params
        }

        <span class="cov8" title="1">var result T
        data, err := json.Marshal(val)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.New("invalid parameter type: " + name)
        }</span>

        <span class="cov8" title="1">err = json.Unmarshal(data, &amp;result)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.New("invalid parameter type: " + name)
        }</span>

        <span class="cov8" title="1">return &amp;result, nil</span>
}

// Generic validation functions

// validateAndAddRequired validates and adds a required parameter of any type
func validateAndAddRequired[T any](
        v *Validator,
        params map[string]interface{},
        name string,
) *Validator <span class="cov8" title="1">{
        value, err := extractValueGeneric[T](v.request, name, true)
        if err != nil </span><span class="cov8" title="1">{
                return v.addError(err)
        }</span>

        <span class="cov8" title="1">if value == nil </span><span class="cov0" title="0">{
                return v
        }</span>

        <span class="cov8" title="1">params[name] = *value
        return v</span>
}

// validateAndAddOptional validates and adds an optional parameter of any type
// if not empty
func validateAndAddOptional[T any](
        v *Validator,
        params map[string]interface{},
        name string,
) *Validator <span class="cov8" title="1">{
        value, err := extractValueGeneric[T](v.request, name, false)
        if err != nil </span><span class="cov8" title="1">{
                return v.addError(err)
        }</span>

        <span class="cov8" title="1">if value == nil </span><span class="cov8" title="1">{
                return v
        }</span>

        <span class="cov8" title="1">params[name] = *value

        return v</span>
}

// validateAndAddToPath is a generic helper to extract a value and write it into
// `target[targetKey]` if non-empty
func validateAndAddToPath[T any](
        v *Validator,
        target map[string]interface{},
        paramName string,
        targetKey string,
) *Validator <span class="cov8" title="1">{
        value, err := extractValueGeneric[T](v.request, paramName, false)
        if err != nil </span><span class="cov8" title="1">{
                return v.addError(err)
        }</span>

        <span class="cov8" title="1">if value == nil </span><span class="cov8" title="1">{
                return v
        }</span>

        <span class="cov8" title="1">target[targetKey] = *value

        return v</span>
}

// ValidateAndAddOptionalStringToPath validates an optional string
// and writes it into target[targetKey]
func (v *Validator) ValidateAndAddOptionalStringToPath(
        target map[string]interface{},
        paramName, targetKey string,
) *Validator <span class="cov8" title="1">{
        return validateAndAddToPath[string](v, target, paramName, targetKey) // nolint:lll
}</span>

// ValidateAndAddOptionalBoolToPath validates an optional bool
// and writes it into target[targetKey]
// only if it was explicitly provided in the request
func (v *Validator) ValidateAndAddOptionalBoolToPath(
        target map[string]interface{},
        paramName, targetKey string,
) *Validator <span class="cov8" title="1">{
        // Now validate and add the parameter
        value, err := extractValueGeneric[bool](v.request, paramName, false)
        if err != nil </span><span class="cov8" title="1">{
                return v.addError(err)
        }</span>

        <span class="cov8" title="1">if value == nil </span><span class="cov8" title="1">{
                return v
        }</span>

        <span class="cov8" title="1">target[targetKey] = *value
        return v</span>
}

// ValidateAndAddOptionalIntToPath validates an optional integer
// and writes it into target[targetKey]
func (v *Validator) ValidateAndAddOptionalIntToPath(
        target map[string]interface{},
        paramName, targetKey string,
) *Validator <span class="cov8" title="1">{
        return validateAndAddToPath[int64](v, target, paramName, targetKey)
}</span>

// Type-specific validator methods

// ValidateAndAddRequiredString validates and adds a required string parameter
func (v *Validator) ValidateAndAddRequiredString(
        params map[string]interface{},
        name string,
) *Validator <span class="cov8" title="1">{
        return validateAndAddRequired[string](v, params, name)
}</span>

// ValidateAndAddOptionalString validates and adds an optional string parameter
func (v *Validator) ValidateAndAddOptionalString(
        params map[string]interface{},
        name string,
) *Validator <span class="cov8" title="1">{
        return validateAndAddOptional[string](v, params, name)
}</span>

// ValidateAndAddRequiredMap validates and adds a required map parameter
func (v *Validator) ValidateAndAddRequiredMap(
        params map[string]interface{},
        name string,
) *Validator <span class="cov8" title="1">{
        return validateAndAddRequired[map[string]interface{}](v, params, name)
}</span>

// ValidateAndAddOptionalMap validates and adds an optional map parameter
func (v *Validator) ValidateAndAddOptionalMap(
        params map[string]interface{},
        name string,
) *Validator <span class="cov8" title="1">{
        return validateAndAddOptional[map[string]interface{}](v, params, name)
}</span>

// ValidateAndAddRequiredArray validates and adds a required array parameter
func (v *Validator) ValidateAndAddRequiredArray(
        params map[string]interface{},
        name string,
) *Validator <span class="cov8" title="1">{
        return validateAndAddRequired[[]interface{}](v, params, name)
}</span>

// ValidateAndAddOptionalArray validates and adds an optional array parameter
func (v *Validator) ValidateAndAddOptionalArray(
        params map[string]interface{},
        name string,
) *Validator <span class="cov8" title="1">{
        return validateAndAddOptional[[]interface{}](v, params, name)
}</span>

// ValidateAndAddPagination validates and adds pagination parameters
// (count and skip)
func (v *Validator) ValidateAndAddPagination(
        params map[string]interface{},
) *Validator <span class="cov8" title="1">{
        return v.ValidateAndAddOptionalInt(params, "count").
                ValidateAndAddOptionalInt(params, "skip")
}</span>

// ValidateAndAddExpand validates and adds expand parameters
func (v *Validator) ValidateAndAddExpand(
        params map[string]interface{},
) *Validator <span class="cov8" title="1">{
        expand, err := extractValueGeneric[[]string](v.request, "expand", false)
        if err != nil </span><span class="cov8" title="1">{
                return v.addError(err)
        }</span>

        <span class="cov8" title="1">if expand == nil </span><span class="cov8" title="1">{
                return v
        }</span>

        <span class="cov8" title="1">if len(*expand) &gt; 0 </span><span class="cov8" title="1">{
                for _, val := range *expand </span><span class="cov8" title="1">{
                        params["expand[]"] = val
                }</span>
        }
        <span class="cov8" title="1">return v</span>
}

// ValidateAndAddRequiredInt validates and adds a required integer parameter
func (v *Validator) ValidateAndAddRequiredInt(
        params map[string]interface{},
        name string,
) *Validator <span class="cov8" title="1">{
        return validateAndAddRequired[int64](v, params, name)
}</span>

// ValidateAndAddOptionalInt validates and adds an optional integer parameter
func (v *Validator) ValidateAndAddOptionalInt(
        params map[string]interface{},
        name string,
) *Validator <span class="cov8" title="1">{
        return validateAndAddOptional[int64](v, params, name)
}</span>

// ValidateAndAddRequiredFloat validates and adds a required float parameter
func (v *Validator) ValidateAndAddRequiredFloat(
        params map[string]interface{},
        name string,
) *Validator <span class="cov8" title="1">{
        return validateAndAddRequired[float64](v, params, name)
}</span>

// ValidateAndAddOptionalFloat validates and adds an optional float parameter
func (v *Validator) ValidateAndAddOptionalFloat(
        params map[string]interface{},
        name string,
) *Validator <span class="cov8" title="1">{
        return validateAndAddOptional[float64](v, params, name)
}</span>

// ValidateAndAddRequiredBool validates and adds a required boolean parameter
func (v *Validator) ValidateAndAddRequiredBool(
        params map[string]interface{},
        name string,
) *Validator <span class="cov8" title="1">{
        return validateAndAddRequired[bool](v, params, name)
}</span>

// ValidateAndAddOptionalBool validates and adds an optional boolean parameter
// Note: This adds the boolean value only
// if it was explicitly provided in the request
func (v *Validator) ValidateAndAddOptionalBool(
        params map[string]interface{},
        name string,
) *Validator <span class="cov8" title="1">{
        // Now validate and add the parameter
        value, err := extractValueGeneric[bool](v.request, name, false)
        if err != nil </span><span class="cov8" title="1">{
                return v.addError(err)
        }</span>

        <span class="cov8" title="1">if value == nil </span><span class="cov8" title="1">{
                return v
        }</span>

        <span class="cov8" title="1">params[name] = *value
        return v</span>
}

// validateTokenMaxAmount validates the max_amount field in token.
// max_amount is required and must be a positive number representing
// the maximum amount that can be debited from the customer's account.
func (v *Validator) validateTokenMaxAmount(
        token map[string]interface{}) *Validator <span class="cov8" title="1">{
        if maxAmount, exists := token["max_amount"]; exists </span><span class="cov8" title="1">{
                switch amt := maxAmount.(type) </span>{
                case float64:<span class="cov8" title="1">
                        if amt &lt;= 0 </span><span class="cov8" title="1">{
                                return v.addError(errors.New("token.max_amount must be greater than 0"))
                        }</span>
                case int:<span class="cov8" title="1">
                        if amt &lt;= 0 </span><span class="cov8" title="1">{
                                return v.addError(errors.New("token.max_amount must be greater than 0"))
                        }</span>
                        <span class="cov8" title="1">token["max_amount"] = float64(amt)</span> // Convert int to float64
                default:<span class="cov8" title="1">
                        return v.addError(errors.New("token.max_amount must be a number"))</span>
                }
        } else<span class="cov8" title="1"> {
                return v.addError(errors.New("token.max_amount is required"))
        }</span>
        <span class="cov8" title="1">return v</span>
}

// validateTokenExpireAt validates the expire_at field in token.
// expire_at is optional and defaults to today + 60 days if not provided.
// If provided, it must be a positive Unix timestamp indicating when the
// mandate/token should expire.
func (v *Validator) validateTokenExpireAt(
        token map[string]interface{}) *Validator <span class="cov8" title="1">{
        if expireAt, exists := token["expire_at"]; exists </span><span class="cov8" title="1">{
                switch exp := expireAt.(type) </span>{
                case float64:<span class="cov8" title="1">
                        if exp &lt;= 0 </span><span class="cov8" title="1">{
                                return v.addError(errors.New("token.expire_at must be greater than 0"))
                        }</span>
                case int:<span class="cov8" title="1">
                        if exp &lt;= 0 </span><span class="cov8" title="1">{
                                return v.addError(errors.New("token.expire_at must be greater than 0"))
                        }</span>
                        <span class="cov8" title="1">token["expire_at"] = float64(exp)</span> // Convert int to float64
                default:<span class="cov8" title="1">
                        return v.addError(errors.New("token.expire_at must be a number"))</span>
                }
        } else<span class="cov8" title="1"> {
                // Set default value to today + 60 days
                defaultExpireAt := time.Now().AddDate(0, 0, 60).Unix()
                token["expire_at"] = float64(defaultExpireAt)
        }</span>
        <span class="cov8" title="1">return v</span>
}

// validateTokenFrequency validates the frequency field in token.
// frequency is required and must be one of the allowed values:
// "as_presented", "monthly", "one_time", "yearly", "weekly", "daily".
func (v *Validator) validateTokenFrequency(
        token map[string]interface{}) *Validator <span class="cov8" title="1">{
        if frequency, exists := token["frequency"]; exists </span><span class="cov8" title="1">{
                if freqStr, ok := frequency.(string); ok </span><span class="cov8" title="1">{
                        validFrequencies := []string{
                                "as_presented", "monthly", "one_time", "yearly", "weekly", "daily"}
                        for _, validFreq := range validFrequencies </span><span class="cov8" title="1">{
                                if freqStr == validFreq </span><span class="cov8" title="1">{
                                        return v
                                }</span>
                        }
                        <span class="cov8" title="1">return v.addError(errors.New(
                                "token.frequency must be one of: as_presented, " +
                                        "monthly, one_time, yearly, weekly, daily"))</span>
                }
                <span class="cov8" title="1">return v.addError(errors.New("token.frequency must be a string"))</span>
        }
        <span class="cov8" title="1">return v.addError(errors.New("token.frequency is required"))</span>
}

// validateTokenType validates the type field in token.
// type is required and must be "single_block_multiple_debit" for SBMD mandates.
func (v *Validator) validateTokenType(token map[string]interface{}) *Validator <span class="cov8" title="1">{
        if tokenType, exists := token["type"]; exists </span><span class="cov8" title="1">{
                if typeStr, ok := tokenType.(string); ok </span><span class="cov8" title="1">{
                        validTypes := []string{"single_block_multiple_debit"}
                        for _, validType := range validTypes </span><span class="cov8" title="1">{
                                if typeStr == validType </span><span class="cov8" title="1">{
                                        return v
                                }</span>
                        }
                        <span class="cov8" title="1">return v.addError(errors.New(
                                "token.type must be one of: single_block_multiple_debit"))</span>
                }
                <span class="cov8" title="1">return v.addError(errors.New("token.type must be a string"))</span>
        }
        <span class="cov8" title="1">return v.addError(errors.New("token.type is required"))</span>
}

// ValidateAndAddToken validates and adds a token object with proper structure.
// The token object is used for mandate orders and must contain:
//   - max_amount: positive number (maximum debit amount)
//   - expire_at: optional Unix timestamp (mandate expiry,
//     defaults to today + 60 days)
//   - frequency: string (debit frequency: as_presented, monthly, one_time,
//     yearly, weekly, daily)
//   - type: string (mandate type: single_block_multiple_debit)
func (v *Validator) ValidateAndAddToken(
        params map[string]interface{}, name string) *Validator <span class="cov8" title="1">{
        value, err := extractValueGeneric[map[string]interface{}](
                v.request, name, false)
        if err != nil </span><span class="cov8" title="1">{
                return v.addError(err)
        }</span>

        <span class="cov8" title="1">if value == nil </span><span class="cov8" title="1">{
                return v
        }</span>

        <span class="cov8" title="1">token := *value

        // Validate all token fields
        v.validateTokenMaxAmount(token).
                validateTokenExpireAt(token).
                validateTokenFrequency(token).
                validateTokenType(token)

        if v.HasErrors() </span><span class="cov8" title="1">{
                return v
        }</span>

        <span class="cov8" title="1">params[name] = token
        return v</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package toolsets

import (
        "fmt"

        "github.com/razorpay/razorpay-mcp-server/pkg/mcpgo"
)

// Toolset represents a group of related tools
type Toolset struct {
        Name        string
        Description string
        Enabled     bool
        readOnly    bool
        writeTools  []mcpgo.Tool
        readTools   []mcpgo.Tool
}

// ToolsetGroup manages multiple toolsets
type ToolsetGroup struct {
        Toolsets     map[string]*Toolset
        everythingOn bool
        readOnly     bool
}

// NewToolset creates a new toolset with the given name and description
func NewToolset(name string, description string) *Toolset <span class="cov8" title="1">{
        return &amp;Toolset{
                Name:        name,
                Description: description,
                Enabled:     false,
                readOnly:    false,
        }
}</span>

// NewToolsetGroup creates a new toolset group
func NewToolsetGroup(readOnly bool) *ToolsetGroup <span class="cov8" title="1">{
        return &amp;ToolsetGroup{
                Toolsets:     make(map[string]*Toolset),
                everythingOn: false,
                readOnly:     readOnly,
        }
}</span>

// AddWriteTools adds write tools to the toolset
func (t *Toolset) AddWriteTools(tools ...mcpgo.Tool) *Toolset <span class="cov8" title="1">{
        if !t.readOnly </span><span class="cov8" title="1">{
                t.writeTools = append(t.writeTools, tools...)
        }</span>
        <span class="cov8" title="1">return t</span>
}

// AddReadTools adds read tools to the toolset
func (t *Toolset) AddReadTools(tools ...mcpgo.Tool) *Toolset <span class="cov8" title="1">{
        t.readTools = append(t.readTools, tools...)
        return t
}</span>

// RegisterTools registers all active tools with the server
func (t *Toolset) RegisterTools(s mcpgo.Server) <span class="cov8" title="1">{
        if !t.Enabled </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">for _, tool := range t.readTools </span><span class="cov8" title="1">{
                s.AddTools(tool)
        }</span>
        <span class="cov8" title="1">if !t.readOnly </span><span class="cov8" title="1">{
                for _, tool := range t.writeTools </span><span class="cov8" title="1">{
                        s.AddTools(tool)
                }</span>
        }
}

// AddToolset adds a toolset to the group
func (tg *ToolsetGroup) AddToolset(ts *Toolset) <span class="cov8" title="1">{
        if tg.readOnly </span><span class="cov8" title="1">{
                ts.readOnly = true
        }</span>
        <span class="cov8" title="1">tg.Toolsets[ts.Name] = ts</span>
}

// EnableToolset enables a specific toolset
func (tg *ToolsetGroup) EnableToolset(name string) error <span class="cov8" title="1">{
        toolset, exists := tg.Toolsets[name]
        if !exists </span><span class="cov8" title="1">{
                return fmt.Errorf("toolset %s does not exist", name)
        }</span>
        <span class="cov8" title="1">toolset.Enabled = true
        return nil</span>
}

// EnableToolsets enables multiple toolsets
func (tg *ToolsetGroup) EnableToolsets(names []string) error <span class="cov8" title="1">{
        if len(names) == 0 </span><span class="cov8" title="1">{
                tg.everythingOn = true
        }</span>

        <span class="cov8" title="1">for _, name := range names </span><span class="cov8" title="1">{
                err := tg.EnableToolset(name)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">if tg.everythingOn </span><span class="cov8" title="1">{
                for name := range tg.Toolsets </span><span class="cov8" title="1">{
                        err := tg.EnableToolset(name)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// RegisterTools registers all active toolsets with the server
func (tg *ToolsetGroup) RegisterTools(s mcpgo.Server) <span class="cov8" title="1">{
        for _, toolset := range tg.Toolsets </span><span class="cov8" title="1">{
                toolset.RegisterTools(s)
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
